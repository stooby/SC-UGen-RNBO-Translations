{
	"patcher" : 	{
		"fileversion" : 1,
		"appversion" : 		{
			"major" : 8,
			"minor" : 6,
			"revision" : 4,
			"architecture" : "x64",
			"modernui" : 1
		}
,
		"classnamespace" : "rnbo",
		"rect" : [ 134.0, 87.0, 896.0, 732.0 ],
		"bglocked" : 0,
		"openinpresentation" : 0,
		"default_fontsize" : 12.0,
		"default_fontface" : 0,
		"default_fontname" : "Lato",
		"gridonopen" : 1,
		"gridsize" : [ 15.0, 15.0 ],
		"gridsnaponopen" : 1,
		"objectsnaponopen" : 1,
		"statusbarvisible" : 2,
		"toolbarvisible" : 1,
		"lefttoolbarpinned" : 0,
		"toptoolbarpinned" : 0,
		"righttoolbarpinned" : 0,
		"bottomtoolbarpinned" : 0,
		"toolbars_unpinned_last_save" : 0,
		"tallnewobj" : 0,
		"boxanimatetime" : 200,
		"enablehscroll" : 1,
		"enablevscroll" : 1,
		"devicewidth" : 0.0,
		"description" : "",
		"digest" : "",
		"tags" : "",
		"style" : "",
		"subpatcher_template" : "",
		"assistshowspatchername" : 0,
		"title" : "Onset",
		"boxes" : [ 			{
				"box" : 				{
					"id" : "obj-1",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 2415.0, 101.0, 209.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"enum" : "",
						"displayname" : "",
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 9,
					"rnbo_uniqueid" : "fftsize",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param fftsize #1 @min 64 @max 2048",
					"varname" : "fftsize"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-107",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 294.0, 118.0, 60.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 11,
					"rnbo_uniqueid" : "set_obj-107",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set fftsize"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-108",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 294.0, 88.0, 130.0, 23.0 ],
					"rnbo_classname" : "receive",
					"rnbo_serial" : 3,
					"rnbo_uniqueid" : "receive_obj-108",
					"text" : "receive local:set_fftsize"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-103",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 2448.0, 172.0, 117.0, 23.0 ],
					"rnbo_classname" : "send",
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "send_obj-103",
					"text" : "send local:set_fftsize"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-33",
					"maxclass" : "flonum",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"parameter_enable" : 0,
					"patching_rect" : [ 378.0, 605.0, 76.0, 23.0 ],
					"rnbo_classname" : "number",
					"rnbo_extra_attributes" : 					{
						"maximum" : "<none>",
						"minimum" : "<none>",
						"preset" : 0,
						"order" : "",
						"initialFormat" : "float"
					}
,
					"rnbo_serial" : 4,
					"rnbo_uniqueid" : "number_obj-33"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-26",
					"maxclass" : "flonum",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"parameter_enable" : 0,
					"patching_rect" : [ 286.0, 605.0, 50.0, 23.0 ],
					"rnbo_classname" : "number",
					"rnbo_extra_attributes" : 					{
						"maximum" : "<none>",
						"minimum" : "<none>",
						"preset" : 0,
						"order" : "",
						"initialFormat" : "float"
					}
,
					"rnbo_serial" : 5,
					"rnbo_uniqueid" : "number_obj-26"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-19",
					"maxclass" : "flonum",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"parameter_enable" : 0,
					"patching_rect" : [ 194.0, 605.0, 50.0, 23.0 ],
					"rnbo_classname" : "number",
					"rnbo_extra_attributes" : 					{
						"maximum" : "<none>",
						"minimum" : "<none>",
						"preset" : 0,
						"order" : "",
						"initialFormat" : "float"
					}
,
					"rnbo_serial" : 6,
					"rnbo_uniqueid" : "number_obj-19"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-92",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 2379.0, 172.0, 60.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 13,
					"rnbo_uniqueid" : "set_obj-92",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set fftsize"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-89",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1977.0, 162.0, 69.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 14,
					"rnbo_uniqueid" : "set_obj-89",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set odftype"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-87",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1977.0, 84.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "ODF Type (0 - 6): Power, Magsum, Complex, RComplex, Phase, WPhase, MKL",
						"meta" : ""
					}
,
					"rnbo_serial" : 9,
					"rnbo_uniqueid" : "in_obj-87",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 9",
								"displayName" : "ODF Type (0 - 6): Power, Magsum, Complex, RComplex, Phase, WPhase, MKL",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 9"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-86",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1740.0, 157.0, 75.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 15,
					"rnbo_uniqueid" : "set_obj-86",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set medspan"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-85",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 1740.0, 122.0, 210.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"enum" : "",
						"displayname" : "",
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 10,
					"rnbo_uniqueid" : "medspan",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param medspan 11 @min 0 @max 256",
					"varname" : "medspan"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-84",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1740.0, 84.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "MedSpan (0 - 256)",
						"meta" : ""
					}
,
					"rnbo_serial" : 10,
					"rnbo_uniqueid" : "in_obj-84",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 8",
								"displayName" : "MedSpan (0 - 256)",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 8"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-83",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1504.0, 153.0, 66.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 16,
					"rnbo_uniqueid" : "set_obj-83",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set mingap"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-82",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 1504.0, 122.0, 201.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"enum" : "",
						"displayname" : "",
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 11,
					"rnbo_uniqueid" : "mingap",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param mingap 10 @min 0 @max 256",
					"varname" : "mingap"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-81",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1305.0, 153.0, 52.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 17,
					"rnbo_uniqueid" : "set_obj-81",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set floor"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-80",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 1305.0, 122.0, 182.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"enum" : "",
						"displayname" : "",
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 12,
					"rnbo_uniqueid" : "floor",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param floor 0.1 @min 0. @max 1.",
					"varname" : "floor"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-79",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1086.0, 153.0, 76.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 18,
					"rnbo_uniqueid" : "set_obj-79",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set relaxtime"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-78",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 1086.0, 122.0, 199.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"enum" : "",
						"displayname" : "",
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 13,
					"rnbo_uniqueid" : "relaxtime",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param relaxtime 1. @min 0. @max 4.",
					"varname" : "relaxtime"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-77",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 885.0, 153.0, 61.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 19,
					"rnbo_uniqueid" : "set_obj-77",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set thresh"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-76",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 885.0, 122.0, 191.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"enum" : "",
						"displayname" : "",
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 14,
					"rnbo_uniqueid" : "thresh",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param thresh 0.5 @min 0. @max 1.",
					"varname" : "thresh"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-75",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 678.0, 153.0, 81.0, 23.0 ],
					"rnbo_classname" : "set",
					"rnbo_serial" : 20,
					"rnbo_uniqueid" : "set_obj-75",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "attribute/param to control",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "input",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "attribute or parameter value (bang, number, list)",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "output",
								"type" : [ "bang", "number", "list", "signal" ],
								"digest" : "connect to first inlet of gen or subpatcher",
								"docked" : 0
							}
 ],
						"helpname" : "set",
						"aliasOf" : "set",
						"classname" : "set",
						"operator" : 0,
						"versionId" : 2121358407,
						"changesPatcherIO" : 0
					}
,
					"text" : "set needs_init"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-74",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 678.0, 122.0, 195.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"enum" : "",
						"displayname" : "",
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 15,
					"rnbo_uniqueid" : "needs_init",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param needs_init 1 @min 0 @max 1",
					"varname" : "needs_init"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-73",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1504.0, 84.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "MinGap (0 - 256)",
						"meta" : ""
					}
,
					"rnbo_serial" : 11,
					"rnbo_uniqueid" : "in_obj-73",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 7",
								"displayName" : "MinGap (0 - 256)",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 7"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-72",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1305.0, 84.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "Floor (0.0 - 1.0)",
						"meta" : ""
					}
,
					"rnbo_serial" : 12,
					"rnbo_uniqueid" : "in_obj-72",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 6",
								"displayName" : "Floor (0.0 - 1.0)",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 6"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-71",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 1086.0, 84.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "Relax Time (0.0 - 4.0)",
						"meta" : ""
					}
,
					"rnbo_serial" : 13,
					"rnbo_uniqueid" : "in_obj-71",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 5",
								"displayName" : "Relax Time (0.0 - 4.0)",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 5"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-70",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 885.0, 84.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "Threshold (0.0 - 1.0)",
						"meta" : ""
					}
,
					"rnbo_serial" : 14,
					"rnbo_uniqueid" : "in_obj-70",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 4",
								"displayName" : "Threshold (0.0 - 1.0)",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 4"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-69",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 678.0, 84.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "Init",
						"meta" : ""
					}
,
					"rnbo_serial" : 15,
					"rnbo_uniqueid" : "in_obj-69",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 3",
								"displayName" : "Init",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 3"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-68",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 566.0, 50.0, 28.0, 23.0 ],
					"rnbo_classname" : "in",
					"rnbo_extra_attributes" : 					{
						"comment" : "Enable",
						"meta" : ""
					}
,
					"rnbo_serial" : 16,
					"rnbo_uniqueid" : "in_obj-68",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value from inlet with index 2",
								"displayName" : "Enable",
								"docked" : 0
							}
 ],
						"helpname" : "in",
						"aliasOf" : "in",
						"classname" : "in",
						"operator" : 0,
						"versionId" : 1219109108,
						"changesPatcherIO" : 1
					}
,
					"text" : "in 2"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-50",
					"maxclass" : "toggle",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "int" ],
					"parameter_enable" : 0,
					"patching_rect" : [ 566.0, 84.0, 24.0, 24.0 ],
					"rnbo_classname" : "toggle",
					"rnbo_extra_attributes" : 					{
						"preset" : 0,
						"order" : ""
					}
,
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "toggle_obj-50"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-49",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 605.0, 157.0, 50.0, 23.0 ],
					"rnbo_classname" : "metro",
					"rnbo_extra_attributes" : 					{
						"lock" : 0.0
					}
,
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "metro_obj-49",
					"text" : "metro 1"
				}

			}
, 			{
				"box" : 				{
					"code" : "//copy fftstream data of current buffer to fftbuf\r\n//and translate it to be compatible with SC FFT format\r\n//dc | nyq | bin1 (r) | bin 1 (i) | bin2 (r) | bin2 (i) ...\r\n\r\n@state fftbuf = new buffer(\"local:fftbuf_1\"); //reference to data \"fftbuf\" object in RNBO patch\r\n//const fftsize : Int = 512;\r\n@param fftsize = 64;\r\n@state last_fftsize = 0;\r\nconst write_to_fftbuf : Int = 1; //<---enable/disable output\r\nconst enable_test : Int = 0;\r\n\r\nvar testval : number;\r\n\r\nvar real = in1;\r\nvar imaginary = in2;\r\nvar fft_index = intnum(in3);\r\n\r\n/*\r\nif (bin_index == 0) {//basic test\r\n\ttestval *= -1; //oscillate between +/- 1 every fftstream~ block size\r\n}\r\n*/\r\n\r\nif (!(last_fftsize == fftsize)) {\r\n\tpost(\"in-fftstream --> NEW FFTSIZE = \", fftsize);\r\n\tpost(\"in-fftstream --> LAST FFTSIZE = \", last_fftsize);\r\n\tlast_fftsize = fftsize;\r\n}\r\n\r\n\r\nif (enable_test) {testval = fft_index;} //for testing\r\n\r\nif (fft_index < 1) {//dc\r\n\t//post(\"fft_index == 0\");\r\n\tif (write_to_fftbuf) {\r\n\t\tif (enable_test) {\r\n\t\t\tpoke(fftbuf, 123456, 0); //test\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpoke(fftbuf, in1, 0); //copy real\r\n\t\t}\r\n\t}\r\n}\r\nelse if (fft_index >= 1 && fft_index < fftsize/2) {\r\n\t//bins 1 through (nyquist - 1)\r\n\t//post(\"fft_index > 0 && fft_index < fftsize/2\");\r\n\t\r\n\tif (write_to_fftbuf) {\r\n\t\tvar index_x : Int = fft_index * 2;\r\n\t\tvar index_y : Int = index_x + 1;\r\n\t\t\r\n\t\tif (enable_test) {\r\n\t\t\tvar testval2 : number = testval + 0.1;\r\n\t\t\tpoke(fftbuf, testval, index_x); //for testing\r\n\t\t\tpoke(fftbuf, testval2, index_y); //for testing\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpoke(fftbuf, in1, index_x); //copy real\r\n\t\t\tpoke(fftbuf, in2, index_y); //copy imaginary\r\n\t\t}\r\n\t}\r\n}\r\nelse if (fft_index == fftsize/2) {//nyquist\r\n\t//post(\"fft_index == fftsize/2\");\r\n\t//copy nyquist to fftbuf index 1 for compatibility w/ SC FFT format\r\n\tif (write_to_fftbuf) {\r\n\t\tif (enable_test) {\r\n\t\t\tpoke(fftbuf, testval, 1); \r\n\t\t}\r\n\t\telse {\r\n\t\t\tpoke(fftbuf, in1, 1); //copy real\r\n\t\t}\r\n\t}\r\n}\r\n",
					"fontface" : 0,
					"fontname" : "<Monospaced>",
					"fontsize" : 12.0,
					"id" : "obj-32",
					"maxclass" : "codebox~",
					"numinlets" : 3,
					"numoutlets" : 0,
					"patching_rect" : [ 52.0, 181.0, 491.0, 321.0 ],
					"rnbo_classname" : "codebox~",
					"rnbo_extra_attributes" : 					{
						"code" : "//copy fftstream data of current buffer to fftbuf\r\n//and translate it to be compatible with SC FFT format\r\n//dc | nyq | bin1 (r) | bin 1 (i) | bin2 (r) | bin2 (i) ...\r\n\r\n@state fftbuf = new buffer(\"local:fftbuf_1\"); //reference to data \"fftbuf\" object in RNBO patch\r\n//const fftsize : Int = 512;\r\n@param fftsize = 64;\r\n@state last_fftsize = 0;\r\nconst write_to_fftbuf : Int = 1; //<---enable/disable output\r\nconst enable_test : Int = 0;\r\n\r\nvar testval : number;\r\n\r\nvar real = in1;\r\nvar imaginary = in2;\r\nvar fft_index = intnum(in3);\r\n\r\n/*\r\nif (bin_index == 0) {//basic test\r\n\ttestval *= -1; //oscillate between +/- 1 every fftstream~ block size\r\n}\r\n*/\r\n\r\nif (!(last_fftsize == fftsize)) {\r\n\tpost(\"in-fftstream --> NEW FFTSIZE = \", fftsize);\r\n\tpost(\"in-fftstream --> LAST FFTSIZE = \", last_fftsize);\r\n\tlast_fftsize = fftsize;\r\n}\r\n\r\n\r\nif (enable_test) {testval = fft_index;} //for testing\r\n\r\nif (fft_index < 1) {//dc\r\n\t//post(\"fft_index == 0\");\r\n\tif (write_to_fftbuf) {\r\n\t\tif (enable_test) {\r\n\t\t\tpoke(fftbuf, 123456, 0); //test\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpoke(fftbuf, in1, 0); //copy real\r\n\t\t}\r\n\t}\r\n}\r\nelse if (fft_index >= 1 && fft_index < fftsize/2) {\r\n\t//bins 1 through (nyquist - 1)\r\n\t//post(\"fft_index > 0 && fft_index < fftsize/2\");\r\n\t\r\n\tif (write_to_fftbuf) {\r\n\t\tvar index_x : Int = fft_index * 2;\r\n\t\tvar index_y : Int = index_x + 1;\r\n\t\t\r\n\t\tif (enable_test) {\r\n\t\t\tvar testval2 : number = testval + 0.1;\r\n\t\t\tpoke(fftbuf, testval, index_x); //for testing\r\n\t\t\tpoke(fftbuf, testval2, index_y); //for testing\r\n\t\t}\r\n\t\telse {\r\n\t\t\tpoke(fftbuf, in1, index_x); //copy real\r\n\t\t\tpoke(fftbuf, in2, index_y); //copy imaginary\r\n\t\t}\r\n\t}\r\n}\r\nelse if (fft_index == fftsize/2) {//nyquist\r\n\t//post(\"fft_index == fftsize/2\");\r\n\t//copy nyquist to fftbuf index 1 for compatibility w/ SC FFT format\r\n\tif (write_to_fftbuf) {\r\n\t\tif (enable_test) {\r\n\t\t\tpoke(fftbuf, testval, 1); \r\n\t\t}\r\n\t\telse {\r\n\t\t\tpoke(fftbuf, in1, 1); //copy real\r\n\t\t}\r\n\t}\r\n}\r\n",
						"safemath" : 1,
						"expr" : ""
					}
,
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "codebox~_obj-32",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset all state and params to initial values",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"in1" : 							{
								"attrOrProp" : 1,
								"digest" : "in1",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"in2" : 							{
								"attrOrProp" : 1,
								"digest" : "in2",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"in3" : 							{
								"attrOrProp" : 1,
								"digest" : "in3",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"fftsize" : 							{
								"attrOrProp" : 1,
								"digest" : "fftsize",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "64"
							}
,
							"expr" : 							{
								"attrOrProp" : 2,
								"digest" : "expr",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"safemath" : 							{
								"attrOrProp" : 2,
								"digest" : "Use safe math expressions (e.g.: division by 0 will not crash).",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true"
							}

						}
,
						"inputs" : [ 							{
								"name" : "in1",
								"type" : "auto",
								"digest" : "in1",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "in2",
								"type" : "auto",
								"digest" : "in2",
								"docked" : 0
							}
, 							{
								"name" : "in3",
								"type" : "auto",
								"digest" : "in3",
								"docked" : 0
							}
 ],
						"outputs" : [  ],
						"helpname" : "codebox~",
						"aliasOf" : "expr~",
						"classname" : "codebox~",
						"operator" : 0,
						"versionId" : 999733430,
						"changesPatcherIO" : 0
					}

				}

			}
, 			{
				"box" : 				{
					"id" : "obj-30",
					"maxclass" : "button",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "bang" ],
					"parameter_enable" : 0,
					"patching_rect" : [ 194.0, 521.0, 24.0, 24.0 ],
					"rnbo_classname" : "button",
					"rnbo_serial" : 8,
					"rnbo_uniqueid" : "button_obj-30"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-22",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 3,
					"outlettype" : [ "", "", "" ],
					"patching_rect" : [ 194.0, 564.0, 224.0, 23.0 ],
					"rnbo_classname" : "data",
					"rnbo_extra_attributes" : 					{
						"file" : "",
						"samplerate" : 0.0,
						"type" : "",
						"fill" : ""
					}
,
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "data_obj-22",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"info" : 							{
								"attrOrProp" : 1,
								"digest" : "Bang to report buffer information.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 0,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "bang"
							}
,
							"sizeout" : 							{
								"attrOrProp" : 1,
								"digest" : "Size in Samples",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 0,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"chanout" : 							{
								"attrOrProp" : 1,
								"digest" : "Number of Channels",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"srout" : 							{
								"attrOrProp" : 1,
								"digest" : "Sample rate",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"size" : 							{
								"attrOrProp" : 1,
								"digest" : "Size in Samples. Take care when setting, allocation might block audio processing.",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [ "samples" ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"samples" : 							{
								"attrOrProp" : 1,
								"digest" : "Size in Samples. Take care when setting, allocation might block audio processing.",
								"defaultarg" : 2,
								"isalias" : 1,
								"aliasOf" : "size",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"sizems" : 							{
								"attrOrProp" : 1,
								"digest" : "Size in Milliseconds. Take care when setting, allocation might block audio processing.",
								"isalias" : 0,
								"aliases" : [ "ms" ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"ms" : 							{
								"attrOrProp" : 1,
								"digest" : "Size in Milliseconds. Take care when setting, allocation might block audio processing.",
								"isalias" : 1,
								"aliasOf" : "sizems",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"clear" : 							{
								"attrOrProp" : 1,
								"digest" : "Clear the contents of the buffer",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalize" : 							{
								"attrOrProp" : 1,
								"digest" : "Find Maximum and normalize to the value given.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0.995"
							}
,
							"channels" : 							{
								"attrOrProp" : 1,
								"digest" : "Change channel count. Take care when setting, allocation might block audio processing.",
								"defaultarg" : 3,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the data buffer",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"mandatory" : 1
							}
,
							"file" : 							{
								"attrOrProp" : 2,
								"digest" : "File name/path or URL to load into buffer.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"url" : 							{
								"attrOrProp" : 2,
								"digest" : "The name of an audio file to load",
								"isalias" : 1,
								"aliasOf" : "file",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"type" : 							{
								"attrOrProp" : 2,
								"digest" : "Type of Data (float32, float64)",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"samplerate" : 							{
								"attrOrProp" : 2,
								"digest" : "Sample rate",
								"defaultarg" : 4,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0"
							}
,
							"fill" : 							{
								"attrOrProp" : 2,
								"digest" : "Fill expression, this could be a value, or a simple function like sin(x), where x will run from 0 to 1 to fill the buffer.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"external" : 							{
								"attrOrProp" : 2,
								"digest" : "Await data from the outside world.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"doNotShowInMaxInspector" : 1
							}

						}
,
						"inputs" : [ 							{
								"name" : "info",
								"type" : "bang",
								"digest" : "Bang to report buffer information.",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "sizeout",
								"type" : "number",
								"digest" : "Size in Samples",
								"defaultarg" : 2,
								"docked" : 0
							}
, 							{
								"name" : "chanout",
								"type" : "number",
								"digest" : "Number of Channels",
								"docked" : 0
							}
, 							{
								"name" : "srout",
								"type" : "number",
								"digest" : "Sample rate",
								"docked" : 0
							}
 ],
						"helpname" : "buffer~",
						"aliasOf" : "data",
						"classname" : "data",
						"operator" : 0,
						"versionId" : 51756089,
						"changesPatcherIO" : 0
					}
,
					"text" : "data local:fftbuf_1 @size #1 @channels 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-39",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 2592.0, 31.0, 150.0, 21.0 ]
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-35",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 663.0, 1072.0, 63.0, 21.0 ]
				}

			}
, 			{
				"box" : 				{
					"code" : "////////////////////////////////////////////////////////////////////////////////\n// Macros and consts\n\n@state ods_log1 = -2.30258509; //negative # can't be const literal, so need to use @state instead...\n\n//#define PI 3.1415926535898f //pi\n//#define MINUSPI -3.1415926535898f\n//#define TWOPI 6.28318530717952646f //twopi\n//#define INV_TWOPI 0.1591549430919f\nconst inv_twopi = 0.1591549430919;\n\n//#define ODS_LOG_LOWER_LIMIT 2e-42\nconst ods_log_power_limit = 2e-42; //2 * 10^-42\n//#define ODS_LOGOF_LOG_LOWER_LIMIT -96.0154267\n@state ods_logof_log_lower_limit = -96.0154267;\n//#define ODS_ABSINVOF_LOGOF_LOG_LOWER_LIMIT 0.010414993\nconst ods_absinvof_logof_log_lower_limit = 0.010414993;\n\n//add enable_logging const\n//@state enable_logging = 1;\n\n////////////////////////////////////////////////////////////////////////////////\n// Constants\n\n//Onsets.kr(chain, threshold: 0.5, odftype: 'rcomplex', relaxtime: 1, floor: 0.1, mingap: 10, medianspan: 11, whtype: 1, rawodf: 0)\n//not sure if I need to make parameter for rawodf (probably not)\n\n\n//Threshold (of ODF value, after median processing) for detection. typically between 0 and 1, although in rare cases you may find values outside this range useful.\n@param({min: 0.0, max: 1.0}) thresh = 0.5;\n@state last_thresh = 0.0;\n\n\n//relaxtime and floor are parameters to the whitening process used, a kind of normalisation of the FFT signal. (Note: in \\mkl mode these are not used.)\n//relaxtime specifies the time (in seconds) for the normalisation to \"forget\" about a recent onset. If you find too much re-triggering (e.g. as a note dies away unevenly) then you might wish to increase this value.\n@param({min: 0.0, max: 4.0}) relaxtime = 1.0; // Do NOT set this directly. Use onsetsds_setrelax() which will also update relaxcoef.\n@state last_relaxtime = 0.0;\n\n//floor is a lower limit, connected to the idea of how quiet the sound is expected to get without becoming indistinguishable from noise. For some cleanly-recorded classical music with wide dynamic variations, I found it helpful to go down as far as 0.000001.\n@param({min: 0.0, max: 1.0}) floor = 0.1;\n@state last_floor = 0.0;\n\n//mingap specifies a minimum gap (in FFT frames) between onset detections, a brute-force way to prevent too many doubled detections.\n@param({min: 0, max: 256}) mingap = 10;\n@state last_mingap = 0;\n\n//medianspan specifies the size (in FFT frames) of the median window used for smoothing the detection function before triggering.\n@param({min: 0, max: 256}) medspan = 11;\n@state last_medspan = 0;\n\n\n/**\n * Types of incoming FFT data format. OnsetsDS needs to know where the FFT\n * data comes from in order to interpret it correctly.\n */\n\n/*\nenum onsetsds_fft_types {\n    ODS_FFT_SC3_COMPLEX, ///< SuperCollider, cartesian co-ords (\"SCComplexBuf\") - NB it's more efficient to provide\n                         ///< polar data from SC\n    ODS_FFT_SC3_POLAR, ///< SuperCollider, polar co-ords (\"SCPolarBuf\")\n    ODS_FFT_FFTW3_HC, ///< FFTW <a\n                      ///< href=\"http://www.fftw.org/fftw3_doc/The-Halfcomplex_002dformat-DFT.html\">\"halfcomplex\"</a>\n                      ///< format\n    ODS_FFT_FFTW3_R2C ///< FFTW regular format, typically produced using <a\n                      ///< href=\"http://www.fftw.org/fftw3_doc/One_002dDimensional-DFTs-of-Real-Data.html#One_002dDimensional-DFTs-of-Real-Data\">real-to-complex</a>\n                      ///< transform\n};\n*/\n\n//not needed in Max RNBO b/c we're only ever converting to Polar (and original source only ever used this and hard coded the 'polar' setting too)\n//@param({ enum: [ \"ods_fft_sc3_complex\", \"ods_fft_sc3_polar\", \"ods_fft_fftw3_hc\", \"ods_fft_fftw3_r2c\"] }) fftformat = 1; //ods_fft_sc3_polar is only ever used in Onsets.cpp: Onsets_next()->onsetsds_init()\n\n/**\n * Types of onset detection function\n */\n/*\nenum onsetsds_odf_types {\n    ODS_ODF_POWER, ///< Power\n    ODS_ODF_MAGSUM, ///< Sum of magnitudes\n    ODS_ODF_COMPLEX, ///< Complex-domain deviation\n    ODS_ODF_RCOMPLEX, ///< Complex-domain deviation, rectified (only increases counted)\n    ODS_ODF_PHASE, ///< Phase deviation\n    ODS_ODF_WPHASE, ///< Weighted phase deviation\n    ODS_ODF_MKL ///< Modified Kullback-Liebler deviation\n};\n*/\n@param({enum: [\"power\", \"magsum\", \"complex\", \"rcomplex\", \"phase\", \"wphase\", \"mkl\"] }) odftype = 1;\n@state last_odftype = 0;\n/**\n * Types of whitening - may not all be implemented yet.\n */\n/*\nenum onsetsds_wh_types {\n    ODS_WH_NONE, ///< No whitening - onsetsds_whiten() becomes a no-op\n    ODS_WH_ADAPT_MAX1, ///< Adaptive whitening - tracks recent-peak-magnitude in each bin, normalises that to 1\n    ODS_WH_NORMMAX, ///< Simple normalisation - each frame is normalised (independent of others) so largest magnitude\n                    ///< becomes 1. Not implemented.\n    ODS_WH_NORMMEAN ///< Simple normalisation - each frame is normalised (independent of others) so mean magnitude\n                    ///< becomes 1. Not implemented.\n};\n*/\n@param({ enum: [\"wh_none\", \"wh_adapt_max1\"] }) whtype = 1; //this isn't ever changed anywhere\n\n@param({min: 64, max: 2048}) fftsize = 64;\n@state last_fftsize = 0;\n\n@param({min: 0, max: 1}) needs_init = 1; //for use in Onsets_next() - translated from Onsets.cpp\n@state last_needs_init = 0;\n\n//max size needed for max fftsize, medspan, and odftypes: 2048 | 256 | complex/rcomplex\nconst onsetdetector_data_array_size : Int = 6654;\n@state onsetdetector_data_array = new FixedFloatArray(onsetdetector_data_array_size);\n\n@state fftbuf = new buffer(\"local:fftbuf_1\"); //reference to data \"fftbuf\" object in RNBO patch\n////////////////////////////////////////////////////////////////////////////////\n// Structs\n\n//since this is a struct, doesn't translate directly to Max as a static FixedArray @state var...will have to maintain this expected structure w/in larger 'onsetdetector_data_array' FixedArray where:\n    //mag = [n+0] index | phase = [n+1] index\n/*\ntypedef struct OdsPolarBin {\n    float mag, phase;\n} OdsPolarBin;\n*/\n\n//since this is a struct, doesn't translate directly to Max as a static FixedArray @state var...will have to maintain this expected structure w/in larger 'onsetdetector_data_array' FixedArray where:\n    //dc = [n+0] | nyq = [n+1] | bin1 mag = [n+2] | bin1 phase = [n+3] | bin2 mag = [n+4] | bin2 phase = [n+5] | etc...\n//IMPORTANT NOTE: since in Max RNBO codebox we're only dealing w/ single sample streams of data instead of buffers, I think we'll only ever be dealing w/ 1 single bin of data at a time in the \"OdsPolarBuf\" struct context and not having to iterate through potentially larger amounts of bins in this struct like done in original SC source...\n/*\ntypedef struct OdsPolarBuf {\n    float dc, nyq;\n    OdsPolarBin bin[1];\n} OdsPolarBuf;\n*/\n\n\n// The main data structure for the onset detection routine\n//typedef struct OnsetsDS {} //this is abstracted away via @state and @param vars\n\n// \"data\" is a pointer to the memory that must be EXTERNALLY allocated.\n// Other pointers will point to locations within this memory.\n//float *data,\n@state odsdata_size : Int = 0; //added in Max RNBO code to track the total size needed (max index) out of the larger onsetdetector_data_array (in lieu of float* odsdata from original SC source) - should always be <= onsetdetector_data_array_size\n\n//*psp,\n//expected to be an index in onsetdetector_data_array\n@state psp : Int = 0; //< Peak Spectral Profile - size is numbins+2, data is stored in order dc through to nyquist\n\n//*odfvals,\n//expected to be an index in onsetdetector_data_array\n@state odfvals : Int = 0; //odfvals[0] will be the current val, odfvals[1] prev, etc...\n\n//*sortbuf,\n//expected to be an index in onsetdetector_data_array\n@state sortbuf : Int = 0; // Used to calculate the median\n\n//*other;\n//expected to be an index in onsetdetector_data_array\n@state other : Int = 0; // Typically stores data about the previous frame\n\n//is this what odsPolarBuf FixedArray above should be used for??? <----\n//OdsPolarBuf* curr; // Current FFT frame, as polar (onsetdetector_data_array[0])\n\n//srate variable not needed I think, can just use samplerate() operator...\n\n@state relaxcoef : number = 0.0; //Relaxation coefficient (memory coefficient). See also onsetsds_setrelax()\n@state odfparam : number = 0.0; // A parameter for the ODF. For most this is a magnitude threshold for a single bin to be considered; but for #ODS_ODF_MKL it is the \"epsilon\" parameter.\n@state normfactor : number = 0.0; // Value used internally to scale ODF value according to the FFT frame size. Automatically set by onsetsds_init()\n@state odfvalpost : number = 0.0; // ODF val after median processing\n@state odfvalpostprev : number = 0.0; // Previous val is needed for threshold-crossing detection\n\n//@state odftype : Int = 1; //Choose from #onsetsds_odf_types (@param above instead)\n//@state whtype : Int = 1; //Choose from #onsetsds_wh_types (@param above instead)\n//@state fftformat : Int = 1; //Choose from #onsetsds_fft_types (@param above instead)\n\n@state whiten : Int = 1; //Whether to apply whitening - onsetsds_init() decides this on your behalf\n@state detected : Int = 0; //Output val - true if onset detected in curr frame\n@state med_odd : Int = 0; //Whether median span is odd or not (used internally)\n@state gapleft : Int = 0;\n//@state fftsize : Int = 0;\n@state numbins : Int = 0; // numbins is the count not including DC/nyq\n\n\n//===================================\n//this can be commented out and is abstracted away by @state and @param values...\n/*\ntypedef struct OnsetsDS {\n    /// \"data\" is a pointer to the memory that must be EXTERNALLY allocated.\n    /// Other pointers will point to locations within this memory.\n    float *data, //<--- @state TRANSLATED (became odsdata_size)\n        *psp, //<--- @state TRANSLATED //< Peak Spectral Profile - size is numbins+2, data is stored in order dc through to nyquist\n        *odfvals, //<--- @state TRANSLATED // odfvals[0] will be the current val, odfvals[1] prev, etc\n        *sortbuf, //<--- @state TRANSLATED // Used to calculate the median\n        *other; //<--- @state TRANSLATED // Typically stores data about the previous frame\n    OdsPolarBuf* curr; // <--- translated (Current FFT frame, as polar)\n    \n    float srate, ///< The sampling rate of the input audio. Set by onsetsds_init()\n                 // Adaptive whitening params\n        relaxtime, //@param <---TRANSLATED ///< Do NOT set this directly. Use onsetsds_setrelax() which will also update relaxcoef.\n        relaxcoef, //@state <---TRANSLATED ///< Relaxation coefficient (memory coefficient). See also onsetsds_setrelax()\n        floor, //@param <---TRANSLATED ///< floor - the lowest value that a PSP magnitude can take.\n        /// A parameter for the ODF. For most this is a magnitude threshold for a single bin to be considered;\n        /// but for #ODS_ODF_MKL it is the \"epsilon\" parameter.\n        odfparam, //@state <---TRANSLATED\n        /// Value used internally to scale ODF value according to the FFT frame size. Automatically set by\n        /// onsetsds_init()\n        normfactor, //@state <---TRANSLATED\n        // ODF val after median processing\n        odfvalpost, //@state <---TRANSLATED\n        // Previous val is needed for threshold-crossing detection\n        odfvalpostprev, //@state <---TRANSLATED\n        /// Threshold (of ODF value, after median processing) for detection.\n        /// Values between 0 and 1 are expected, but outside this range may\n        /// sometimes be appropriate too.\n        thresh; //@param <---TRANSLATED\n\n    int odftype, //@parameter <---TRANSLATED ///< Choose from #onsetsds_odf_types\n        whtype, //@parameter <---TRANSLATED ///< Choose from #onsetsds_wh_types\n        fftformat; //@parameter <---TRANSLATED ///< Choose from #onsetsds_fft_types\n    bool whiten, //@state <---TRANSLATED ///< Whether to apply whitening - onsetsds_init() decides this on your behalf\n        detected, //@state <---TRANSLATED ///< Output val - true if onset detected in curr frame\n        /**\n        NOT YET USED: Whether to convert magnitudes to log domain before processing. This is done as follows:\n        Magnitudes below a log-lower-limit threshold (ODS_LOG_LOWER_LIMIT) are pushed up to that threshold (to avoid\n        log(0) infinity problems), then the log is taken. The values are re-scaled to a similar range as the\n        linear-domain values (assumed to lie between zero and approximately one) by subtracting log(ODS_LOG_LOWER_LIMIT)\n        and then dividing by abs(log(ODS_LOG_LOWER_LIMIT)).\n        */\n/*\n        logmags, //not used/tested <---NOT TRANSLATED\n        med_odd; //@state <---TRANSLATED ///< Whether median span is odd or not (used internally)\n\n    unsigned int\n        /// Number of frames used in median calculation\n        medspan, //@param <---TRANSLATED\n        /// Size of enforced gap between detections, measured in FFT frames.\n        mingap, //@param <---TRANSLATED\n        gapleft; //@state <---TRANSLATED\n    size_t fftsize, numbins; //@param / @state <---TRANSLATED // numbins is the count not including DC/nyq\n} OnsetsDS;\n*/\n//===================================\n\n// I think this compensates for SC's ToPolarApx() function returning phase values in less conventional  range of [-pi/4, 7pi/4] - so I don't think I'll have to translate these SC ToPolarApx() functions into RNBO and can just use RNBO's catopol~ conversion as is...\n        //=====> BUT IF OnsetDetection DOESN'T WORK AS EXPECTED, MIGHT NEED TO TRANSLATE ToPolarApx() functions AFTER ALL TO ENSURE FULL 1:1 TRANSLATION OF SC TO RNBO CODE... <========\n    //see 'static inline SCPolarBuf* ToPolarApx(buf)' in \"FFT_Ugens.h\"\n    //and 'Polar Complex::ToPolarApx()' in \"SC_Complex.h\"\n//wraps phase values to be within -PI - +PI range\nfunction onsetsds_phase_rewrap(phase) {\n    return ((phase > (-1 * PI)) && (phase < PI)) ? phase : phase + TWOPI * (1.0 + floor(((-1 * PI) - phase) * inv_twopi));\n}\n\n\n\n/**\n * Determine how many bytes of memory must be allocated (e.g. using malloc) to\n * accompany the OnsetsDS struct, operating using the specified settings (used to\n * store part-processed FFT data etc). The user must\n * call this, and then allocate the memory, BEFORE calling onsetsds_init().\n * @param odftype Which onset detection function (ODF) you'll be using, chosen from #onsetsds_odf_types\n * @param fftsize Size of FFT: 512 is recommended.\n * @param medspan The number of past frames that will be used for median calculation during triggering\n*/\nfunction onsetsds_memneeded(odftype, fftsize, medspan) {\n    //medspan (medianspan) default = 11\n    /*\n    Need memory for:\n    - median calculation (2 * medspan floats)\n    - storing old values (whether as OdsPolarBuf or as weirder float lists)\n    - storing the OdsPolarBuf (size is NOT sizeof(OdsPolarBuf) but is fftsize)\n    - storing the PSP (numbins + 2 values)\n    All these are floats.\n    */\n    var numbins : Int = (fftsize >> 1) - 1; // # of bins, not counting DC/nyq\n    \n    switch (odftype) {\n        case 0: //power\n        case 1: //magsum\n            // No old FFT frames needed, easy:\n            post(\"odftype = power/magsum ---\");\n            return (medspan + medspan + fftsize + numbins + 2);\n        case 2: //complex\n        case 3: //rcomplex\n            post(\"odftype = complex/rcomplex ---\");\n            //these types always require largest memsize <---!!!\n            // For each bin (NOT dc/nyq) we store mag, phase and d_phase\n            return (medspan + medspan + fftsize + numbins + 2 + numbins + numbins + numbins);\n        case 4: //phase\n        case 5: //wphase\n            post(\"odftype = phase/wphase ---\");\n            // For each bin (NOT dc/nyq) we store phase and d_phase\n            return (medspan + medspan + fftsize + numbins + 2 + numbins + numbins);\n        case 6: //mkl\n            //For each bin (NOT dc/nyq) we store mag\n            post(\"odftype = mkl ---\");\n            return (medspan + medspan + fftsize + numbins + 2 + numbins);\n            //break; //not sure if necessary...\n    }\n}\n\n/**\n * Set the \"memory coefficient\" indirectly via the time for the\n * memory to decay by 60 dB.\n * @param ods The OnsetsDS\n * @param time The time in seconds\n * @param hopsize The FFT frame hopsize (typically this will be half the FFT frame size)\n */\nfunction onsetsds_setrelax(set_relaxtime, hopsize) {\n    relaxtime = set_relaxtime;\n    relaxcoef = (set_relaxtime == 0.0) ? 0.0 : exp((ods_log1 * hopsize) / (set_relaxtime * samplerate()));\n}\n\n/**\n * Initialise the OnsetsDS struct and its associated memory, ready to detect\n * onsets using the specified settings. Must be called before any call to\n * onsetsds_process().\n *\n * Note: you can change the onset detection function type in mid-operation\n * by calling onsetsds_init() again, but because memory will be reset this\n * will behave as if starting from scratch (rather than being aware of the past\n * few frames of sound). Do not attempt to change the\n * onset detection function in a more hacky way (e.g. fiddling with the struct)\n * because memory is set up differently for each of the different ODFs.\n * @param ods An instance of the OnsetsDS struct\n * @param odsdata A pointer to the memory allocated, size given by onsetsds_memneeded().\n * @param fftformat Which format of FFT data is to be expected, chosen from #onsetsds_fft_types\n * @param odftype Which onset detection function (ODF) you'll be using, chosen from #onsetsds_odf_types\n * @param fftsize Size of FFT: 512 or 1024 is recommended.\n * @param medspan The number of past frames that will be used for median calculation during triggering\n */\n//void onsetsds_init(OnsetsDS* ods, float* odsdata, int fftformat, int odftype, size_t fftsize, unsigned int medspan, float srate);\nfunction onsetsds_init(odftype, fftsize, medspan) {\n    var realnumbins : Int = 0;\n    \n    // The main pointer to the processing area - other pointers will indicate areas within this\n    //ods->data = odsdata;\n    //in Max, we just need to be aware how far into onsetdetector_data_array we're writing into, represented by ods_data_size\n    odsdata_size = onsetsds_memneeded(odftype, fftsize, medspan); //791 (magsum / fft = 512 / medspan = 11)\n    if (odsdata_size > onsetdetector_data_array_size) {\n        //safeguard against writing out of bounds of onsetdetector_data_array\n        odsdata_size = onsetdetector_data_array_size;\n        post(\"WARNING!!! odsdata_size was > onsetdetector_data_array_size\");\n        post(\"odsdata_size now = onsetdetector_data_array_size\");\n    }\n    \n    // Set all vals in processing area to zero\n    //memset(odsdata, 0, onsetsds_memneeded(odftype, fftsize, medspan));\n    for (var i = 0; i < odsdata_size; i++) {\n        onsetdetector_data_array[i] = 0.0; //0 out data array\n    }\n    \n    //ods->srate = srate; //not necessary in Max\n    \n    numbins = (fftsize >> 1) - 1; // No of bins, not counting DC/nyq (255 for 512 fftsize)\n    realnumbins = numbins + 2; //257\n    \n    // Also point the other pointers to the right places (in Max, these translate to array index values where odsdata = 0 index of onsetdetector_data_array)\n    //ods->curr = (OdsPolarBuf*)odsdata; //point curr (OdsPolarBuf*) to same address as odsdata, which in Max is onsetdetector_data_array[0] <----\n    \n    //ods->psp = odsdata + fftsize;\n    psp = fftsize; //512\n    //ods->odfvals = odsdata + fftsize + realnumbins;\n    odfvals = fftsize + realnumbins; //769\n    //ods->sortbuf = odsdata + fftsize + realnumbins + medspan;\n    sortbuf = fftsize + realnumbins + medspan; //780 (default medspan = 11)\n    //ods->other = odsdata + fftsize + realnumbins + medspan + medspan;\n    other = fftsize + realnumbins + medspan + medspan; //791\n    \n    // Default settings for Adaptive Whitening, user can set own values after init\n    //onsetsds_setrelax(ods, 1.f, fftsize >> 1);\n    //onsetsds_setrelax(1.0, fftsize >> 1); //<----doesn't seem necessary to set to 1.0 b/c this is always set to 'relaxtime' after onsetsds_init is called w/in Onsets_next()\n    //floor = 0.1; //<----don't think I should do this here... (CAUSES A BUG WHEN UNCOMMENTED ON RESET)\n    \n    switch (odftype) {\n    case 0: //POWER\n        odfparam = 0.01; // \"powthresh\" in SC code\n        normfactor = 2560.0 / (realnumbins * fftsize);\n        break;\n    case 1: //MAGSUM\n        odfparam = 0.01; // \"powthresh\" in SC code\n        normfactor = 113.137085 / (realnumbins * safesqrt(fftsize));\n        break;\n    case 2: //COMPLEX\n        odfparam = 0.01;\n        normfactor = 231.70475 / pow(fftsize, 1.5);\n        break;\n    case 3: //RCOMPLEX\n        odfparam = 0.01;\n        normfactor = 231.70475 / pow(fftsize, 1.5);\n        break;\n    case 4: //PHASE\n        odfparam = 0.01;\n        normfactor = 5.12 / fftsize;\n        break;\n    case 5: //WPHASE\n        odfparam = 0.0001; // \"powthresh\" in SC code. For WPHASE it's kind of superfluous.\n        normfactor = 115.852375 / pow(fftsize, 1.5);\n        break;\n    case 6: //MKL\n        odfparam = 0.01; // EPSILON parameter. Brossier recommends 1e-6 but I (ICMC 2007) found larger vals (e.g\n                              // 0.01) to work better\n        normfactor = 7.68 * 0.25 / fftsize;\n        break;\n    default:\n        post(\"onsetsds_init ERROR: odftype is not a valid value\");\n    }\n    \n    odfvalpost = 0.0;\n    odfvalpostprev = 0.0;\n    //thresh = 0.5; //<---- don't reset thresh to 0.5 here (CAUSES A BUG WHEN UNCOMMENTED ON RESET)\n    //ods->logmags = false; //not used\n\n    //ods->odftype = odftype;\n    //whtype = 1; //<----don't think this is necessary b/c this is never set anywhere else and inits to 1\n    //ods->fftformat = fftformat;\n\n    whiten = (odftype != 6); // Deactivate whitening for MKL by default\n    detected = 0;\n    med_odd = (medspan & 1) != 0;\n\n    //ods->medspan = medspan;\n\n    //mingap = 0; //<----don't think I should do this here... (CAUSES A BUG WHEN UNCOMMENTED ON RESET)\n    gapleft = 0; //orig source set this to 0, but consider >= 1 to avoid false positive on reset\n\n    //ods->fftsize = fftsize;\n    //ods->numbins = numbins;\n}\n\n//apply adaptive whitening to the FFT data\nfunction onsetsds_whiten() {\n    var val : number = 0.0;\n    var oldval : number = 0.0;\n    var pspp1 : Int = psp + 1;\n    \n    if (whtype == 0) {//if whtype == wh_none\n        //skip whitening when no whitening applied (e.g. MKL mode)\n        return 0;\n    }\n    \n    // Update the peak value of each bin\n    \n    //val = fabs(curr->dc); // Grab current magnitude (orig source)\n    val = fabs(onsetdetector_data_array[0]); //dc = 0-index of this array\n    \n    //oldval = psp[0]; //source\n    oldval = onsetdetector_data_array[psp];\n    \n    // If new amplitude > stored amp, that becomes new amp\n    // otherwise new amp is decayed version of old one\n    if (val < oldval) {\n        val = val + (oldval - val) * relaxcoef;\n    }\n    \n    //psp[0] = val; // Store the amplitude trace back\n    onsetdetector_data_array[psp] = val;\n    \n    //val = fabs(curr->nyq);\n    val = fabs(onsetdetector_data_array[1]); //nyq = index 1 in this array\n    \n    //oldval = pspp1[numbins];\n    oldval = onsetdetector_data_array[pspp1 + numbins];\n    if (val < oldval) {\n        val = val + (oldval - val) * relaxcoef;\n    }\n    //pspp1[numbins] = val;\n    onsetdetector_data_array[pspp1 + numbins] = val;\n    \n    for (var i = 0; i < numbins; ++i) {\n        var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n        //i = 0 | onsetdetector_data_array[2] (bin[0] mag)\n        //i = 1 | onsetdetector_data_array[4] (bin[1] mag)\n        //i = 2 | onsetdetector_data_array[6] (bin[2] mag)\n\n        //val = fabs(curr->bin[i].mag); //source\n        val = fabs(onsetdetector_data_array[index_bin_mag]);\n        \n        //oldval = pspp1[i]; //source\n        oldval = onsetdetector_data_array[pspp1 + i];\n        \n        if (val < oldval) {\n            val = val + (oldval - val) * relaxcoef;\n        }\n\n        //pspp1[i] = val; //source\n        onsetdetector_data_array[pspp1 + i] = val;\n    }\n    \n    // Rescale the current magnitude of each bin\n    //curr->dc /= ods_max(floor, psp[0]); //source\n    onsetdetector_data_array[0] /= maximum(floor, onsetdetector_data_array[psp]);\n    \n    //curr->nyq /= ods_max(floor, pspp1[numbins]); //source\n    onsetdetector_data_array[1] /= maximum(floor, onsetdetector_data_array[pspp1 + numbins]);\n    \n    for (var i = 0; i < numbins; ++i) {\n        var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n        \n        //curr->bin[i].mag /= ods_max(floor, pspp1[i]); //source\n        onsetdetector_data_array[index_bin_mag] /= maximum(floor, onsetdetector_data_array[pspp1 + i]);\n    }\n    return 0;\n}\n\n\n//calculate the Onset Detection Function (includes scaling ODF outputs to similar range)\nfunction onsetsds_odf() {\n    //OdsPolarBuf* curr = ods->curr; //source (onsetdetector_data_array[0])\n    //float* val = ods->odfvals; //source (val = odfvals)\n    var i : Int = 0;\n    var tbpointer : Int = 0;\n    \n    var deviation : number = 0.0;\n    var diff : number = 0.0;\n    var curmag : number = 0.0;\n    var totdev : number = 0.0;\n    \n    var predmag : number = 0.0;\n    var predphase : number = 0.0;\n    var yesterphase : number = 0.0;\n    var yesterphasediff : number = 0.0;\n    var yestermag : number = 0.0;\n    \n    var rectify : Int = 1;\n    \n    //shunt the \"old\" ODF values down one place\n    //memcpy(val + 1, val, (ods->medspan - 1) * sizeof(float)); //source\n    for (var i : Int = (medspan - 1); i > 0; i--) {\n        //unit tested in Max and works as expected shunting all values down +1 index after odfvals w/out stomping on 'sortbuf' beyond odfvals + medspan\n        onsetdetector_data_array[odfvals + i] = onsetdetector_data_array[odfvals + i - 1];\n        //post(\"---i = \");\n        //post(i);\n    }\n    \n    // Now calculate a new value and store in ods->odfvals[0]\n    switch (odftype) {\n        case 0: //power\n            //*val = (curr->nyq * curr->nyq) + (curr->dc * curr->dc); //source\n            onsetdetector_data_array[odfvals] = (onsetdetector_data_array[1] * onsetdetector_data_array[1]) + (onsetdetector_data_array[0] * onsetdetector_data_array[0]);\n            \n            for (i = 0; i < numbins; i++) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                //*val += curr->bin[i].mag * curr->bin[i].mag; //source\n                onsetdetector_data_array[odfvals] += onsetdetector_data_array[index_bin_mag] * onsetdetector_data_array[index_bin_mag];\n            }\n            break;\n            \n        case 1: //magsum\n            //*val = ods_abs(curr->nyq) + ods_abs(curr->dc); //source\n            onsetdetector_data_array[odfvals] = onsetdetector_data_array[1] + onsetdetector_data_array[0];\n\n            for (i = 0; i < numbins; i++) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                \n                //*val += ods_abs(curr->bin[i].mag); //source\n                onsetdetector_data_array[odfvals] += abs(onsetdetector_data_array[index_bin_mag]);\n            }\n            break;\n            \n        case 2: //complex\n            rectify = 0;\n            // ...and then drop through to:\n            \n        case 3: //rcomplex\n            // Note: \"other\" buf is stored in this format: mag[0],phase[0],d_phase[0],mag[1],phase[1],d_phase[1], ...\n\n            // Iterate through, calculating the deviation from expected value.\n            totdev = 0.0;\n            tbpointer = 0;\n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                \n                //curmag = ods_abs(curr->bin[i].mag); //source\n                curmag = abs(onsetdetector_data_array[index_bin_mag]);\n                \n                // Predict mag as yestermag\n                //predmag = ods->other[tbpointer++]; //source\n                predmag = onsetdetector_data_array[other + (tbpointer++)];\n                //yesterphase = ods->other[tbpointer++]; //source\n                yesterphase = onsetdetector_data_array[other + (tbpointer++)];\n                //yesterphasediff = ods->other[tbpointer++]; //source\n                yesterphasediff = onsetdetector_data_array[other + (tbpointer++)];\n                \n                // Thresholding as Brossier did - discard (ignore) bin's deviation if bin's power is minimal\n                if (curmag > odfparam) {\n                    // If rectifying, ignore decreasing bins\n                    if ((!rectify) || !(curmag < predmag)) {\n                        var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                        //i = 0 | onsetdetector_data_array[3] (bin[0] phase)\n                        //i = 1 | onsetdetector_data_array[5] (bin[1] phase)\n                        //i = 2 | onsetdetector_data_array[7] (bin[2] phase)\n                        //i = 3 | onsetdetector_data_array[9] (bin[3] phase)\n                        \n                        \n                        // Predict phase as yesterval + yesterfirstdiff\n                        predphase = yesterphase + yesterphasediff;\n\n                        // Here temporarily using the \"deviation\" var to store the phase difference\n                        //  so that the rewrap macro can use it more efficiently\n                        //deviation = predphase - curr->bin[i].phase; //source\n                        deviation = predphase - onsetdetector_data_array[index_bin_phase];\n\n                        // Deviation is Euclidean distance between predicted and actual.\n                        // In polar coords: sqrt(r1^2 +  r2^2 - r1r2 cos (theta1 - theta2))\n                        deviation = safesqrt(predmag * predmag + curmag * curmag\n                                          - predmag * curmag * cos(onsetsds_phase_rewrap(deviation)));\n\n                        totdev += deviation;\n                    }\n                }\n            }\n            \n            // totdev will be the output, but first we need to fill tempbuf with today's values, ready for tomorrow.\n            tbpointer = 0;\n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                \n                //ods->other[tbpointer++] = ods_abs(curr->bin[i].mag); // Storing mag (source)\n                onsetdetector_data_array[other + (tbpointer++)] = abs(onsetdetector_data_array[index_bin_mag]); // Storing mag\n                \n                //diff = curr->bin[i].phase - ods->other[tbpointer]; // Retrieving yesterphase from buf (source)\n                diff = onsetdetector_data_array[index_bin_phase] - onsetdetector_data_array[other + tbpointer]; // Retrieving yesterphase from buf\n                \n                //ods->other[tbpointer++] = curr->bin[i].phase; // Storing phase (source)\n                onsetdetector_data_array[other + (tbpointer++)] = onsetdetector_data_array[index_bin_phase]; // Storing phase\n                \n                // Wrap onto +-PI range\n                diff = onsetsds_phase_rewrap(diff);\n\n                //ods->other[tbpointer++] = diff; // Storing first diff to buf (source)\n                onsetdetector_data_array[other + (tbpointer++)] = diff; // Storing first diff to buf\n            }\n            \n            //*val = (float)totdev; //source\n            onsetdetector_data_array[odfvals] = totdev;\n            break;\n            \n        case 4: //phase\n            rectify = 0; //means 'use weighting' here\n            // then drop to:\n            \n        case 5: //wphase\n            // Note: \"other\" buf is stored in this format: phase[0],d_phase[0],phase[1],d_phase[1], ...\n\n            // Iterate through, calculating the deviation from expected value.\n            totdev = 0.0;\n            tbpointer = 0;\n            \n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                \n                // Thresholding as Brossier did - discard (ignore) bin's phase deviation if bin's power is low\n                //if (ods_abs(curr->bin[i].mag) > ods->odfparam) {//source\n                if (abs(onsetdetector_data_array[index_bin_mag]) > odfparam) {\n                    // Deviation is the *second difference* of the phase, which is calc'ed as curval - yesterval -\n                    // yesterfirstdiff\n                    var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                    //deviation = curr->bin[i].phase - ods->other[tbpointer] - ods->other[tbpointer + 1]; //source\n                    deviation = onsetdetector_data_array[index_bin_phase] - onsetdetector_data_array[other + tbpointer] - onsetdetector_data_array[other + tbpointer + 1];\n                    tbpointer += 2;\n                    // Wrap onto +-PI range\n                    deviation = onsetsds_phase_rewrap(deviation);\n\n                    if (rectify) { // \"rectify\" meaning \"useweighting\"...\n                        //totdev += fabs(deviation * ods_abs(curr->bin[i].mag)); //source\n                        totdev += fabs(deviation * abs(onsetdetector_data_array[index_bin_mag]));\n                    } else {\n                        totdev += fabs(deviation);\n                    }\n                }\n            }\n            \n            // totdev will be the output, but first we need to fill tempbuf with today's values, ready for tomorrow.\n            tbpointer = 0;\n            for (i = 0; i < numbins; ++i) {\n                var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                //diff = curr->bin[i].phase - ods->other[tbpointer]; // Retrieving yesterphase from buf (source)\n                diff = onsetdetector_data_array[index_bin_phase] - onsetdetector_data_array[other + tbpointer]; // Retrieving yesterphase from buf\n                //ods->other[tbpointer++] = curr->bin[i].phase; // Storing phase (source)\n                onsetdetector_data_array[other + tbpointer++] = onsetdetector_data_array[index_bin_phase]; // Storing phase\n                // Wrap onto +-PI range\n                diff = onsetsds_phase_rewrap(diff);\n\n                //ods->other[tbpointer++] = diff; // Storing first diff to buf (source)\n                onsetdetector_data_array[other + tbpointer++] = diff; // Storing first diff to buf\n            }\n            //*val = (float)totdev; //<---- source (double cast to float)\n            onsetdetector_data_array[odfvals] = totdev; //pretty sure nothing needed to translate (float) casting here b/c totdev already declared as (double) 'number'\n            break;\n            \n        case 6: //mkl\n            // Iterate through, calculating the Modified Kullback-Liebler distance\n            totdev = 0.0;\n            tbpointer = 0;\n            \n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                //curmag = ods_abs(curr->bin[i].mag); //source\n                curmag = abs(onsetdetector_data_array[index_bin_mag]);\n                \n                //yestermag = ods->other[tbpointer]; //source\n                yestermag = onsetdetector_data_array[other + tbpointer];\n\n                // Here's the main implementation of Brossier's MKL eq'n (eqn 2.9 from his thesis):\n                //deviation = ods_abs(curmag) / (ods_abs(yestermag) + ods->odfparam); //source\n                deviation = abs(curmag) / (abs(yestermag) + odfparam);\n                \n                totdev += log(1.0 + deviation);\n\n                // Store the mag as yestermag\n                //ods->other[tbpointer++] = curmag; //source\n                onsetdetector_data_array[other + tbpointer++] = curmag;\n            }\n            //*val = (float)totdev; //source (double cast to float)\n            onsetdetector_data_array[odfvals] = totdev; //pretty sure nothing needed to translate (float) casting here b/c totdev already declared as (double) 'number'\n            break;\n    }\n    \n    //ods->odfvals[0] *= ods->normfactor; //source\n    onsetdetector_data_array[odfvals] *= normfactor;\n}\n\n//sorts 'sortbuf' + 'medspan' values in onset_detector_data_array from lowest to highest values (unit tested)\n// Algo is simply based on http://en.wikibooks.org/wiki/Algorithm_implementation/Sorting/Selection_sort\n//void SelectionSort(float* array, int length) {\nfunction sort_selection(length) {\n    var maximum : Int;\n    var i : Int;\n    var temp : number = 0.0;\n    while (length > 0) {\n        //WARNING!!! there are no guard rails here to avoid writing out of bounds of onsetdetector_data_array, so if unexpected crashes occur check this function and add safety checks to avoid this <----\n        maximum = 0;\n        for (i = 1; i < length; i++) {\n            //if (array[i] > array[max]) //source\n                //max = i; //source\n            if (onsetdetector_data_array[sortbuf + i] > onsetdetector_data_array[sortbuf + maximum])\n            {maximum = i;}\n        }\n        //temp = array[length - 1]; //source\n        temp = onsetdetector_data_array[sortbuf + length - 1];\n        \n        //array[length - 1] = array[max]; //source\n        onsetdetector_data_array[sortbuf + length - 1] = onsetdetector_data_array[sortbuf + maximum];\n        \n        //array[max] = temp; //source\n        onsetdetector_data_array[sortbuf + maximum] = temp;\n        length--;\n    }\n}\n\n/**\n * Detects salient peaks in Onset Detection Function by removing the median,\n * then thresholding. Afterwards, the member ods.detected will indicate whether\n * or not an onset was detected.\n *\n * Not typically called directly by users since onsetsds_process() calls this.\n */\nfunction onsetsds_detect() {\n    \n    // Update last value of odfvalpost\n    odfvalpostprev = odfvalpost;\n    \n    // MEDIAN REMOVAL //\n    \n    // Copy odfvals to sortbuf\n    //memcpy(sortbuf, ods->odfvals, medspan * sizeof(float)); //source\n    for (var i : Int = 0; i < medspan; i++) {\n        var write_index: Int = sortbuf + i;\n        if (write_index >= onsetdetector_data_array_size) {\n            write_index = onsetdetector_data_array_size - 1;\n            post(\"WARNING!!! sortbuf + i write index >= onsetdetector_data_array_size\");\n            post(\"sortbuf + i write index now = onsetdetector_data_array_size - 1 to avoid crash, but onset detection will probably fail...\");\n        }\n        //unit tested in Max\n        onsetdetector_data_array[sortbuf + i] = onsetdetector_data_array[odfvals + i];\n    }\n    \n    // Sort sortbuf\n    //SelectionSort(sortbuf, medspan); //source\n    sort_selection(medspan);\n    \n    // Subtract the middlest value === the median\n    if (med_odd) {\n        //ods->odfvalpost = ods->odfvals[0] - sortbuf[(medspan - 1) >> 1]; //source\n        var sortbuf_i : Int = (medspan - 1) >> 1;\n        odfvalpost = onsetdetector_data_array[odfvals] - onsetdetector_data_array[sortbuf + sortbuf_i];\n    } else {\n        var sortbuf_i : Int = medspan >> 1;\n        //ods->odfvalpost = ods->odfvals[0] - ((sortbuf[medspan >> 1] + sortbuf[(medspan >> 1) - 1]) * 0.5f); //source\n        odfvalpost = onsetdetector_data_array[odfvals] - ((onsetdetector_data_array[sortbuf + sortbuf_i] + onsetdetector_data_array[sortbuf + sortbuf_i - 1]) * 0.5);\n    }\n    \n    // Detection not allowed if we're too close to a previous detection.\n    if (gapleft != 0) {\n        gapleft--;\n        detected = 0;\n    } else {\n        // Now do the detection.\n        detected = (odfvalpost > thresh) && (odfvalpostprev <= thresh);\n        if (detected) {\n            gapleft = mingap;\n        }\n    }\n}\n\n//Load the current frame of FFT data into onsetdetector_data_array\nfunction onsetsds_loadframe(this_fftsize) {\n    //store all fftbuf data in onsetdetector_data_array and convert to polar...\n    for (var i : Int = 0; i < this_fftsize/2; i++) {\n        if (i < 1) {\n            //post(\"===========\");\n            //no polar conversion needed for these...\n            var dc = peek(fftbuf, 0);\n            var nyq = peek(fftbuf, 1);\n            onsetdetector_data_array[0] = dc[0];\n            onsetdetector_data_array[1] = nyq[0];\n        }\n        else if (i >= 1 && (i < this_fftsize/2)) {\n            var index_x : Int = 2 * i;\n            var index_y : Int = index_x + 1;\n            var real = peek(fftbuf, index_x);\n            var imaginary = peek(fftbuf, index_y);\n            \n            var polar = cartopol(real[0], imaginary[0]);\n            onsetdetector_data_array[index_x] = polar[0]; //mag\n            onsetdetector_data_array[index_y] = polar[1]; //phase\n        }\n    }\n}\n\n/**\n * Process a single FFT data frame in the audio signal. Note that processing\n * assumes that each call to onsetsds_process() is on a subsequent frame in\n * the same audio stream - to handle multiple streams you must use separate\n * OnsetsDS structs and memory!\n *\n * This function's main purpose is to call some of the library's other functions,\n * in the expected sequence.\n */\n//bool onsetsds_process(OnsetsDS* ods, float* fftbuf) {//source\nfunction onsetsds_process() {\n    onsetsds_loadframe(fftsize);\n\n    onsetsds_whiten(); //<---CAUSES warning: 3755:1:non-void function does not return a value in all control paths\n                        //error: 3883:9:non-void function 'codebox_02_onsetsds_whiten' should return a value\n    onsetsds_odf();\n    onsetsds_detect();\n\n    //return ods->detected; //source\n    //return detected; //<---I think this should be fine in RNBO, but try commenting this out if run into issues, since 'detected' is a @state variable and accessible always\n}\n\n\nfunction Onsets_next() {\n    var outval : Int = 0; //maybe not needed if use final output line instead\n    //source --- vvvv --- vvvv ---------------\n    //Onsets_GET_BUF //source <---handled in other 'fftbuf_write' codebox\n    //SCPolarBuf* p = ToPolarApx(buf); buf comes from Onsets_GET_BUF macro <---TRANSLATED INTO onsetsds_loadframe()\n    //OnsetsDS* ods = unit->m_ods;\n    //int odftype = (int)ZIN0(2);\n    //float relaxtime = ZIN0(3);\n    //int medspan = (int)ZIN0(6);\n    //source --- ^^^^ --- ^^^^ ---------------\n    \n    if (needs_init) {\n        \n        // Init happens here because we need to be sure about FFT size (buf->samples)\n        //unit->m_odsdata = (float*)RTAlloc(unit->mWorld, onsetsds_memneeded(odftype, buf->samples, medspan)); //calculate data size and allocate memory for odsdata <---TRANSLATED THIS INTO onsetsds_init()\n        //ClearUnitIfMemFailed(unit->m_odsdata);\n\n        //onsetsds_init(ods, unit->m_odsdata, ODS_FFT_SC3_POLAR, odftype, buf->samples, medspan, FULLRATE); //init ods struct w/ correct data size, pointer addresses, and parameters\n        onsetsds_init(odftype, fftsize, medspan);\n        \n        //onsetsds_setrelax(ods, relaxtime, buf->samples >> 1);\n        onsetsds_setrelax(relaxtime, fftsize >> 1);\n\n        //unit->m_needsinit = false;\n        needs_init = 0;\n    }\n\n    //source --- vvvv --- vvvv ---------------\n    // Here is the best place to set parameters - after init is ensured\n    // These are \"painless\" to set:\n    //ods->thresh = ZIN0(1);\n    //ods->floor = ZIN0(4);\n    //ods->mingap = (int)ZIN0(5);\n    //ods->whtype = (int)ZIN0(7);\n    //source --- ^^^^ --- ^^^^ ---------------\n    \n    // Now to process\n    //unit->outval = onsetsds_process(ods, (float*)p);\n    //outval = onsetsds_process();\n    onsetsds_process();\n    \n    if (detected > 0) {post(\"ONSET DETECTED\");}\n    //ZOUT0(0) = unit->outval;\n    out1 = detected;\n    //out1 = detected;\n}\n\n//===============================\n//===============================\n//=== TOP of odf()===\n\nif (!(last_thresh == thresh)) {\n    post(\"in-odf --> NEW thresh = \", thresh);\n    post(\"in-odf --> LAST thresh = \", last_thresh);\n    last_thresh = thresh;\n}\n\nif (!(last_relaxtime == relaxtime)) {\n    post(\"in-odf --> NEW relaxtime = \", relaxtime);\n    post(\"in-odf --> LAST relaxtime = \", last_relaxtime);\n    last_relaxtime = relaxtime;\n}\n\nif (!(last_floor == floor)) {\n    post(\"in-odf --> NEW floor = \", floor);\n    post(\"in-odf --> LAST floor = \", last_floor);\n    last_floor = floor;\n}\n\nif (!(last_mingap == mingap)) {\n    post(\"in-odf --> NEW mingap = \", mingap);\n    post(\"in-odf --> LAST mingap = \", last_mingap);\n    last_mingap = mingap;\n}\n\nif (!(last_medspan == medspan)) {\n    post(\"in-odf --> NEW medspan = \", medspan);\n    post(\"in-odf --> LAST medspan = \", last_medspan);\n    last_medspan = medspan;\n}\n\nif (!(last_odftype == odftype)) {\n    post(\"in-odf --> NEW odftype = \", odftype);\n    post(\"in-odf --> LAST odftype = \", last_odftype);\n    last_odftype = odftype;\n}\n\nif (!(last_fftsize == fftsize)) {\n    post(\"in-odf --> NEW fftsize = \", fftsize);\n    post(\"in-odf --> LAST fftsize = \", last_fftsize);\n    last_fftsize = fftsize;\n}\n\nif (!(last_needs_init == needs_init)) {\n    post(\"in-odf --> NEW needs_init = \", needs_init);\n    post(\"in-odf --> LAST needs_init = \", last_needs_init);\n    last_needs_init = needs_init;\n}\n\nOnsets_next();\n\n",
					"fontface" : 0,
					"fontname" : "<Monospaced>",
					"fontsize" : 12.0,
					"id" : "obj-34",
					"maxclass" : "codebox",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 666.0, 217.0, 993.0, 744.0 ],
					"rnbo_classname" : "codebox",
					"rnbo_extra_attributes" : 					{
						"code" : "////////////////////////////////////////////////////////////////////////////////\n// Macros and consts\n\n@state ods_log1 = -2.30258509; //negative # can't be const literal, so need to use @state instead...\n\n//#define PI 3.1415926535898f //pi\n//#define MINUSPI -3.1415926535898f\n//#define TWOPI 6.28318530717952646f //twopi\n//#define INV_TWOPI 0.1591549430919f\nconst inv_twopi = 0.1591549430919;\n\n//#define ODS_LOG_LOWER_LIMIT 2e-42\nconst ods_log_power_limit = 2e-42; //2 * 10^-42\n//#define ODS_LOGOF_LOG_LOWER_LIMIT -96.0154267\n@state ods_logof_log_lower_limit = -96.0154267;\n//#define ODS_ABSINVOF_LOGOF_LOG_LOWER_LIMIT 0.010414993\nconst ods_absinvof_logof_log_lower_limit = 0.010414993;\n\n//add enable_logging const\n//@state enable_logging = 1;\n\n////////////////////////////////////////////////////////////////////////////////\n// Constants\n\n//Onsets.kr(chain, threshold: 0.5, odftype: 'rcomplex', relaxtime: 1, floor: 0.1, mingap: 10, medianspan: 11, whtype: 1, rawodf: 0)\n//not sure if I need to make parameter for rawodf (probably not)\n\n\n//Threshold (of ODF value, after median processing) for detection. typically between 0 and 1, although in rare cases you may find values outside this range useful.\n@param({min: 0.0, max: 1.0}) thresh = 0.5;\n@state last_thresh = 0.0;\n\n\n//relaxtime and floor are parameters to the whitening process used, a kind of normalisation of the FFT signal. (Note: in \\mkl mode these are not used.)\n//relaxtime specifies the time (in seconds) for the normalisation to \"forget\" about a recent onset. If you find too much re-triggering (e.g. as a note dies away unevenly) then you might wish to increase this value.\n@param({min: 0.0, max: 4.0}) relaxtime = 1.0; // Do NOT set this directly. Use onsetsds_setrelax() which will also update relaxcoef.\n@state last_relaxtime = 0.0;\n\n//floor is a lower limit, connected to the idea of how quiet the sound is expected to get without becoming indistinguishable from noise. For some cleanly-recorded classical music with wide dynamic variations, I found it helpful to go down as far as 0.000001.\n@param({min: 0.0, max: 1.0}) floor = 0.1;\n@state last_floor = 0.0;\n\n//mingap specifies a minimum gap (in FFT frames) between onset detections, a brute-force way to prevent too many doubled detections.\n@param({min: 0, max: 256}) mingap = 10;\n@state last_mingap = 0;\n\n//medianspan specifies the size (in FFT frames) of the median window used for smoothing the detection function before triggering.\n@param({min: 0, max: 256}) medspan = 11;\n@state last_medspan = 0;\n\n\n/**\n * Types of incoming FFT data format. OnsetsDS needs to know where the FFT\n * data comes from in order to interpret it correctly.\n */\n\n/*\nenum onsetsds_fft_types {\n    ODS_FFT_SC3_COMPLEX, ///< SuperCollider, cartesian co-ords (\"SCComplexBuf\") - NB it's more efficient to provide\n                         ///< polar data from SC\n    ODS_FFT_SC3_POLAR, ///< SuperCollider, polar co-ords (\"SCPolarBuf\")\n    ODS_FFT_FFTW3_HC, ///< FFTW <a\n                      ///< href=\"http://www.fftw.org/fftw3_doc/The-Halfcomplex_002dformat-DFT.html\">\"halfcomplex\"</a>\n                      ///< format\n    ODS_FFT_FFTW3_R2C ///< FFTW regular format, typically produced using <a\n                      ///< href=\"http://www.fftw.org/fftw3_doc/One_002dDimensional-DFTs-of-Real-Data.html#One_002dDimensional-DFTs-of-Real-Data\">real-to-complex</a>\n                      ///< transform\n};\n*/\n\n//not needed in Max RNBO b/c we're only ever converting to Polar (and original source only ever used this and hard coded the 'polar' setting too)\n//@param({ enum: [ \"ods_fft_sc3_complex\", \"ods_fft_sc3_polar\", \"ods_fft_fftw3_hc\", \"ods_fft_fftw3_r2c\"] }) fftformat = 1; //ods_fft_sc3_polar is only ever used in Onsets.cpp: Onsets_next()->onsetsds_init()\n\n/**\n * Types of onset detection function\n */\n/*\nenum onsetsds_odf_types {\n    ODS_ODF_POWER, ///< Power\n    ODS_ODF_MAGSUM, ///< Sum of magnitudes\n    ODS_ODF_COMPLEX, ///< Complex-domain deviation\n    ODS_ODF_RCOMPLEX, ///< Complex-domain deviation, rectified (only increases counted)\n    ODS_ODF_PHASE, ///< Phase deviation\n    ODS_ODF_WPHASE, ///< Weighted phase deviation\n    ODS_ODF_MKL ///< Modified Kullback-Liebler deviation\n};\n*/\n@param({enum: [\"power\", \"magsum\", \"complex\", \"rcomplex\", \"phase\", \"wphase\", \"mkl\"] }) odftype = 1;\n@state last_odftype = 0;\n/**\n * Types of whitening - may not all be implemented yet.\n */\n/*\nenum onsetsds_wh_types {\n    ODS_WH_NONE, ///< No whitening - onsetsds_whiten() becomes a no-op\n    ODS_WH_ADAPT_MAX1, ///< Adaptive whitening - tracks recent-peak-magnitude in each bin, normalises that to 1\n    ODS_WH_NORMMAX, ///< Simple normalisation - each frame is normalised (independent of others) so largest magnitude\n                    ///< becomes 1. Not implemented.\n    ODS_WH_NORMMEAN ///< Simple normalisation - each frame is normalised (independent of others) so mean magnitude\n                    ///< becomes 1. Not implemented.\n};\n*/\n@param({ enum: [\"wh_none\", \"wh_adapt_max1\"] }) whtype = 1; //this isn't ever changed anywhere\n\n@param({min: 64, max: 2048}) fftsize = 64;\n@state last_fftsize = 0;\n\n@param({min: 0, max: 1}) needs_init = 1; //for use in Onsets_next() - translated from Onsets.cpp\n@state last_needs_init = 0;\n\n//max size needed for max fftsize, medspan, and odftypes: 2048 | 256 | complex/rcomplex\nconst onsetdetector_data_array_size : Int = 6654;\n@state onsetdetector_data_array = new FixedFloatArray(onsetdetector_data_array_size);\n\n@state fftbuf = new buffer(\"local:fftbuf_1\"); //reference to data \"fftbuf\" object in RNBO patch\n////////////////////////////////////////////////////////////////////////////////\n// Structs\n\n//since this is a struct, doesn't translate directly to Max as a static FixedArray @state var...will have to maintain this expected structure w/in larger 'onsetdetector_data_array' FixedArray where:\n    //mag = [n+0] index | phase = [n+1] index\n/*\ntypedef struct OdsPolarBin {\n    float mag, phase;\n} OdsPolarBin;\n*/\n\n//since this is a struct, doesn't translate directly to Max as a static FixedArray @state var...will have to maintain this expected structure w/in larger 'onsetdetector_data_array' FixedArray where:\n    //dc = [n+0] | nyq = [n+1] | bin1 mag = [n+2] | bin1 phase = [n+3] | bin2 mag = [n+4] | bin2 phase = [n+5] | etc...\n//IMPORTANT NOTE: since in Max RNBO codebox we're only dealing w/ single sample streams of data instead of buffers, I think we'll only ever be dealing w/ 1 single bin of data at a time in the \"OdsPolarBuf\" struct context and not having to iterate through potentially larger amounts of bins in this struct like done in original SC source...\n/*\ntypedef struct OdsPolarBuf {\n    float dc, nyq;\n    OdsPolarBin bin[1];\n} OdsPolarBuf;\n*/\n\n\n// The main data structure for the onset detection routine\n//typedef struct OnsetsDS {} //this is abstracted away via @state and @param vars\n\n// \"data\" is a pointer to the memory that must be EXTERNALLY allocated.\n// Other pointers will point to locations within this memory.\n//float *data,\n@state odsdata_size : Int = 0; //added in Max RNBO code to track the total size needed (max index) out of the larger onsetdetector_data_array (in lieu of float* odsdata from original SC source) - should always be <= onsetdetector_data_array_size\n\n//*psp,\n//expected to be an index in onsetdetector_data_array\n@state psp : Int = 0; //< Peak Spectral Profile - size is numbins+2, data is stored in order dc through to nyquist\n\n//*odfvals,\n//expected to be an index in onsetdetector_data_array\n@state odfvals : Int = 0; //odfvals[0] will be the current val, odfvals[1] prev, etc...\n\n//*sortbuf,\n//expected to be an index in onsetdetector_data_array\n@state sortbuf : Int = 0; // Used to calculate the median\n\n//*other;\n//expected to be an index in onsetdetector_data_array\n@state other : Int = 0; // Typically stores data about the previous frame\n\n//is this what odsPolarBuf FixedArray above should be used for??? <----\n//OdsPolarBuf* curr; // Current FFT frame, as polar (onsetdetector_data_array[0])\n\n//srate variable not needed I think, can just use samplerate() operator...\n\n@state relaxcoef : number = 0.0; //Relaxation coefficient (memory coefficient). See also onsetsds_setrelax()\n@state odfparam : number = 0.0; // A parameter for the ODF. For most this is a magnitude threshold for a single bin to be considered; but for #ODS_ODF_MKL it is the \"epsilon\" parameter.\n@state normfactor : number = 0.0; // Value used internally to scale ODF value according to the FFT frame size. Automatically set by onsetsds_init()\n@state odfvalpost : number = 0.0; // ODF val after median processing\n@state odfvalpostprev : number = 0.0; // Previous val is needed for threshold-crossing detection\n\n//@state odftype : Int = 1; //Choose from #onsetsds_odf_types (@param above instead)\n//@state whtype : Int = 1; //Choose from #onsetsds_wh_types (@param above instead)\n//@state fftformat : Int = 1; //Choose from #onsetsds_fft_types (@param above instead)\n\n@state whiten : Int = 1; //Whether to apply whitening - onsetsds_init() decides this on your behalf\n@state detected : Int = 0; //Output val - true if onset detected in curr frame\n@state med_odd : Int = 0; //Whether median span is odd or not (used internally)\n@state gapleft : Int = 0;\n//@state fftsize : Int = 0;\n@state numbins : Int = 0; // numbins is the count not including DC/nyq\n\n\n//===================================\n//this can be commented out and is abstracted away by @state and @param values...\n/*\ntypedef struct OnsetsDS {\n    /// \"data\" is a pointer to the memory that must be EXTERNALLY allocated.\n    /// Other pointers will point to locations within this memory.\n    float *data, //<--- @state TRANSLATED (became odsdata_size)\n        *psp, //<--- @state TRANSLATED //< Peak Spectral Profile - size is numbins+2, data is stored in order dc through to nyquist\n        *odfvals, //<--- @state TRANSLATED // odfvals[0] will be the current val, odfvals[1] prev, etc\n        *sortbuf, //<--- @state TRANSLATED // Used to calculate the median\n        *other; //<--- @state TRANSLATED // Typically stores data about the previous frame\n    OdsPolarBuf* curr; // <--- translated (Current FFT frame, as polar)\n    \n    float srate, ///< The sampling rate of the input audio. Set by onsetsds_init()\n                 // Adaptive whitening params\n        relaxtime, //@param <---TRANSLATED ///< Do NOT set this directly. Use onsetsds_setrelax() which will also update relaxcoef.\n        relaxcoef, //@state <---TRANSLATED ///< Relaxation coefficient (memory coefficient). See also onsetsds_setrelax()\n        floor, //@param <---TRANSLATED ///< floor - the lowest value that a PSP magnitude can take.\n        /// A parameter for the ODF. For most this is a magnitude threshold for a single bin to be considered;\n        /// but for #ODS_ODF_MKL it is the \"epsilon\" parameter.\n        odfparam, //@state <---TRANSLATED\n        /// Value used internally to scale ODF value according to the FFT frame size. Automatically set by\n        /// onsetsds_init()\n        normfactor, //@state <---TRANSLATED\n        // ODF val after median processing\n        odfvalpost, //@state <---TRANSLATED\n        // Previous val is needed for threshold-crossing detection\n        odfvalpostprev, //@state <---TRANSLATED\n        /// Threshold (of ODF value, after median processing) for detection.\n        /// Values between 0 and 1 are expected, but outside this range may\n        /// sometimes be appropriate too.\n        thresh; //@param <---TRANSLATED\n\n    int odftype, //@parameter <---TRANSLATED ///< Choose from #onsetsds_odf_types\n        whtype, //@parameter <---TRANSLATED ///< Choose from #onsetsds_wh_types\n        fftformat; //@parameter <---TRANSLATED ///< Choose from #onsetsds_fft_types\n    bool whiten, //@state <---TRANSLATED ///< Whether to apply whitening - onsetsds_init() decides this on your behalf\n        detected, //@state <---TRANSLATED ///< Output val - true if onset detected in curr frame\n        /**\n        NOT YET USED: Whether to convert magnitudes to log domain before processing. This is done as follows:\n        Magnitudes below a log-lower-limit threshold (ODS_LOG_LOWER_LIMIT) are pushed up to that threshold (to avoid\n        log(0) infinity problems), then the log is taken. The values are re-scaled to a similar range as the\n        linear-domain values (assumed to lie between zero and approximately one) by subtracting log(ODS_LOG_LOWER_LIMIT)\n        and then dividing by abs(log(ODS_LOG_LOWER_LIMIT)).\n        */\n/*\n        logmags, //not used/tested <---NOT TRANSLATED\n        med_odd; //@state <---TRANSLATED ///< Whether median span is odd or not (used internally)\n\n    unsigned int\n        /// Number of frames used in median calculation\n        medspan, //@param <---TRANSLATED\n        /// Size of enforced gap between detections, measured in FFT frames.\n        mingap, //@param <---TRANSLATED\n        gapleft; //@state <---TRANSLATED\n    size_t fftsize, numbins; //@param / @state <---TRANSLATED // numbins is the count not including DC/nyq\n} OnsetsDS;\n*/\n//===================================\n\n// I think this compensates for SC's ToPolarApx() function returning phase values in less conventional  range of [-pi/4, 7pi/4] - so I don't think I'll have to translate these SC ToPolarApx() functions into RNBO and can just use RNBO's catopol~ conversion as is...\n        //=====> BUT IF OnsetDetection DOESN'T WORK AS EXPECTED, MIGHT NEED TO TRANSLATE ToPolarApx() functions AFTER ALL TO ENSURE FULL 1:1 TRANSLATION OF SC TO RNBO CODE... <========\n    //see 'static inline SCPolarBuf* ToPolarApx(buf)' in \"FFT_Ugens.h\"\n    //and 'Polar Complex::ToPolarApx()' in \"SC_Complex.h\"\n//wraps phase values to be within -PI - +PI range\nfunction onsetsds_phase_rewrap(phase) {\n    return ((phase > (-1 * PI)) && (phase < PI)) ? phase : phase + TWOPI * (1.0 + floor(((-1 * PI) - phase) * inv_twopi));\n}\n\n\n\n/**\n * Determine how many bytes of memory must be allocated (e.g. using malloc) to\n * accompany the OnsetsDS struct, operating using the specified settings (used to\n * store part-processed FFT data etc). The user must\n * call this, and then allocate the memory, BEFORE calling onsetsds_init().\n * @param odftype Which onset detection function (ODF) you'll be using, chosen from #onsetsds_odf_types\n * @param fftsize Size of FFT: 512 is recommended.\n * @param medspan The number of past frames that will be used for median calculation during triggering\n*/\nfunction onsetsds_memneeded(odftype, fftsize, medspan) {\n    //medspan (medianspan) default = 11\n    /*\n    Need memory for:\n    - median calculation (2 * medspan floats)\n    - storing old values (whether as OdsPolarBuf or as weirder float lists)\n    - storing the OdsPolarBuf (size is NOT sizeof(OdsPolarBuf) but is fftsize)\n    - storing the PSP (numbins + 2 values)\n    All these are floats.\n    */\n    var numbins : Int = (fftsize >> 1) - 1; // # of bins, not counting DC/nyq\n    \n    switch (odftype) {\n        case 0: //power\n        case 1: //magsum\n            // No old FFT frames needed, easy:\n            post(\"odftype = power/magsum ---\");\n            return (medspan + medspan + fftsize + numbins + 2);\n        case 2: //complex\n        case 3: //rcomplex\n            post(\"odftype = complex/rcomplex ---\");\n            //these types always require largest memsize <---!!!\n            // For each bin (NOT dc/nyq) we store mag, phase and d_phase\n            return (medspan + medspan + fftsize + numbins + 2 + numbins + numbins + numbins);\n        case 4: //phase\n        case 5: //wphase\n            post(\"odftype = phase/wphase ---\");\n            // For each bin (NOT dc/nyq) we store phase and d_phase\n            return (medspan + medspan + fftsize + numbins + 2 + numbins + numbins);\n        case 6: //mkl\n            //For each bin (NOT dc/nyq) we store mag\n            post(\"odftype = mkl ---\");\n            return (medspan + medspan + fftsize + numbins + 2 + numbins);\n            //break; //not sure if necessary...\n    }\n}\n\n/**\n * Set the \"memory coefficient\" indirectly via the time for the\n * memory to decay by 60 dB.\n * @param ods The OnsetsDS\n * @param time The time in seconds\n * @param hopsize The FFT frame hopsize (typically this will be half the FFT frame size)\n */\nfunction onsetsds_setrelax(set_relaxtime, hopsize) {\n    relaxtime = set_relaxtime;\n    relaxcoef = (set_relaxtime == 0.0) ? 0.0 : exp((ods_log1 * hopsize) / (set_relaxtime * samplerate()));\n}\n\n/**\n * Initialise the OnsetsDS struct and its associated memory, ready to detect\n * onsets using the specified settings. Must be called before any call to\n * onsetsds_process().\n *\n * Note: you can change the onset detection function type in mid-operation\n * by calling onsetsds_init() again, but because memory will be reset this\n * will behave as if starting from scratch (rather than being aware of the past\n * few frames of sound). Do not attempt to change the\n * onset detection function in a more hacky way (e.g. fiddling with the struct)\n * because memory is set up differently for each of the different ODFs.\n * @param ods An instance of the OnsetsDS struct\n * @param odsdata A pointer to the memory allocated, size given by onsetsds_memneeded().\n * @param fftformat Which format of FFT data is to be expected, chosen from #onsetsds_fft_types\n * @param odftype Which onset detection function (ODF) you'll be using, chosen from #onsetsds_odf_types\n * @param fftsize Size of FFT: 512 or 1024 is recommended.\n * @param medspan The number of past frames that will be used for median calculation during triggering\n */\n//void onsetsds_init(OnsetsDS* ods, float* odsdata, int fftformat, int odftype, size_t fftsize, unsigned int medspan, float srate);\nfunction onsetsds_init(odftype, fftsize, medspan) {\n    var realnumbins : Int = 0;\n    \n    // The main pointer to the processing area - other pointers will indicate areas within this\n    //ods->data = odsdata;\n    //in Max, we just need to be aware how far into onsetdetector_data_array we're writing into, represented by ods_data_size\n    odsdata_size = onsetsds_memneeded(odftype, fftsize, medspan); //791 (magsum / fft = 512 / medspan = 11)\n    if (odsdata_size > onsetdetector_data_array_size) {\n        //safeguard against writing out of bounds of onsetdetector_data_array\n        odsdata_size = onsetdetector_data_array_size;\n        post(\"WARNING!!! odsdata_size was > onsetdetector_data_array_size\");\n        post(\"odsdata_size now = onsetdetector_data_array_size\");\n    }\n    \n    // Set all vals in processing area to zero\n    //memset(odsdata, 0, onsetsds_memneeded(odftype, fftsize, medspan));\n    for (var i = 0; i < odsdata_size; i++) {\n        onsetdetector_data_array[i] = 0.0; //0 out data array\n    }\n    \n    //ods->srate = srate; //not necessary in Max\n    \n    numbins = (fftsize >> 1) - 1; // No of bins, not counting DC/nyq (255 for 512 fftsize)\n    realnumbins = numbins + 2; //257\n    \n    // Also point the other pointers to the right places (in Max, these translate to array index values where odsdata = 0 index of onsetdetector_data_array)\n    //ods->curr = (OdsPolarBuf*)odsdata; //point curr (OdsPolarBuf*) to same address as odsdata, which in Max is onsetdetector_data_array[0] <----\n    \n    //ods->psp = odsdata + fftsize;\n    psp = fftsize; //512\n    //ods->odfvals = odsdata + fftsize + realnumbins;\n    odfvals = fftsize + realnumbins; //769\n    //ods->sortbuf = odsdata + fftsize + realnumbins + medspan;\n    sortbuf = fftsize + realnumbins + medspan; //780 (default medspan = 11)\n    //ods->other = odsdata + fftsize + realnumbins + medspan + medspan;\n    other = fftsize + realnumbins + medspan + medspan; //791\n    \n    // Default settings for Adaptive Whitening, user can set own values after init\n    //onsetsds_setrelax(ods, 1.f, fftsize >> 1);\n    //onsetsds_setrelax(1.0, fftsize >> 1); //<----doesn't seem necessary to set to 1.0 b/c this is always set to 'relaxtime' after onsetsds_init is called w/in Onsets_next()\n    //floor = 0.1; //<----don't think I should do this here... (CAUSES A BUG WHEN UNCOMMENTED ON RESET)\n    \n    switch (odftype) {\n    case 0: //POWER\n        odfparam = 0.01; // \"powthresh\" in SC code\n        normfactor = 2560.0 / (realnumbins * fftsize);\n        break;\n    case 1: //MAGSUM\n        odfparam = 0.01; // \"powthresh\" in SC code\n        normfactor = 113.137085 / (realnumbins * safesqrt(fftsize));\n        break;\n    case 2: //COMPLEX\n        odfparam = 0.01;\n        normfactor = 231.70475 / pow(fftsize, 1.5);\n        break;\n    case 3: //RCOMPLEX\n        odfparam = 0.01;\n        normfactor = 231.70475 / pow(fftsize, 1.5);\n        break;\n    case 4: //PHASE\n        odfparam = 0.01;\n        normfactor = 5.12 / fftsize;\n        break;\n    case 5: //WPHASE\n        odfparam = 0.0001; // \"powthresh\" in SC code. For WPHASE it's kind of superfluous.\n        normfactor = 115.852375 / pow(fftsize, 1.5);\n        break;\n    case 6: //MKL\n        odfparam = 0.01; // EPSILON parameter. Brossier recommends 1e-6 but I (ICMC 2007) found larger vals (e.g\n                              // 0.01) to work better\n        normfactor = 7.68 * 0.25 / fftsize;\n        break;\n    default:\n        post(\"onsetsds_init ERROR: odftype is not a valid value\");\n    }\n    \n    odfvalpost = 0.0;\n    odfvalpostprev = 0.0;\n    //thresh = 0.5; //<---- don't reset thresh to 0.5 here (CAUSES A BUG WHEN UNCOMMENTED ON RESET)\n    //ods->logmags = false; //not used\n\n    //ods->odftype = odftype;\n    //whtype = 1; //<----don't think this is necessary b/c this is never set anywhere else and inits to 1\n    //ods->fftformat = fftformat;\n\n    whiten = (odftype != 6); // Deactivate whitening for MKL by default\n    detected = 0;\n    med_odd = (medspan & 1) != 0;\n\n    //ods->medspan = medspan;\n\n    //mingap = 0; //<----don't think I should do this here... (CAUSES A BUG WHEN UNCOMMENTED ON RESET)\n    gapleft = 0; //orig source set this to 0, but consider >= 1 to avoid false positive on reset\n\n    //ods->fftsize = fftsize;\n    //ods->numbins = numbins;\n}\n\n//apply adaptive whitening to the FFT data\nfunction onsetsds_whiten() {\n    var val : number = 0.0;\n    var oldval : number = 0.0;\n    var pspp1 : Int = psp + 1;\n    \n    if (whtype == 0) {//if whtype == wh_none\n        //skip whitening when no whitening applied (e.g. MKL mode)\n        return 0;\n    }\n    \n    // Update the peak value of each bin\n    \n    //val = fabs(curr->dc); // Grab current magnitude (orig source)\n    val = fabs(onsetdetector_data_array[0]); //dc = 0-index of this array\n    \n    //oldval = psp[0]; //source\n    oldval = onsetdetector_data_array[psp];\n    \n    // If new amplitude > stored amp, that becomes new amp\n    // otherwise new amp is decayed version of old one\n    if (val < oldval) {\n        val = val + (oldval - val) * relaxcoef;\n    }\n    \n    //psp[0] = val; // Store the amplitude trace back\n    onsetdetector_data_array[psp] = val;\n    \n    //val = fabs(curr->nyq);\n    val = fabs(onsetdetector_data_array[1]); //nyq = index 1 in this array\n    \n    //oldval = pspp1[numbins];\n    oldval = onsetdetector_data_array[pspp1 + numbins];\n    if (val < oldval) {\n        val = val + (oldval - val) * relaxcoef;\n    }\n    //pspp1[numbins] = val;\n    onsetdetector_data_array[pspp1 + numbins] = val;\n    \n    for (var i = 0; i < numbins; ++i) {\n        var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n        //i = 0 | onsetdetector_data_array[2] (bin[0] mag)\n        //i = 1 | onsetdetector_data_array[4] (bin[1] mag)\n        //i = 2 | onsetdetector_data_array[6] (bin[2] mag)\n\n        //val = fabs(curr->bin[i].mag); //source\n        val = fabs(onsetdetector_data_array[index_bin_mag]);\n        \n        //oldval = pspp1[i]; //source\n        oldval = onsetdetector_data_array[pspp1 + i];\n        \n        if (val < oldval) {\n            val = val + (oldval - val) * relaxcoef;\n        }\n\n        //pspp1[i] = val; //source\n        onsetdetector_data_array[pspp1 + i] = val;\n    }\n    \n    // Rescale the current magnitude of each bin\n    //curr->dc /= ods_max(floor, psp[0]); //source\n    onsetdetector_data_array[0] /= maximum(floor, onsetdetector_data_array[psp]);\n    \n    //curr->nyq /= ods_max(floor, pspp1[numbins]); //source\n    onsetdetector_data_array[1] /= maximum(floor, onsetdetector_data_array[pspp1 + numbins]);\n    \n    for (var i = 0; i < numbins; ++i) {\n        var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n        \n        //curr->bin[i].mag /= ods_max(floor, pspp1[i]); //source\n        onsetdetector_data_array[index_bin_mag] /= maximum(floor, onsetdetector_data_array[pspp1 + i]);\n    }\n    return 0;\n}\n\n\n//calculate the Onset Detection Function (includes scaling ODF outputs to similar range)\nfunction onsetsds_odf() {\n    //OdsPolarBuf* curr = ods->curr; //source (onsetdetector_data_array[0])\n    //float* val = ods->odfvals; //source (val = odfvals)\n    var i : Int = 0;\n    var tbpointer : Int = 0;\n    \n    var deviation : number = 0.0;\n    var diff : number = 0.0;\n    var curmag : number = 0.0;\n    var totdev : number = 0.0;\n    \n    var predmag : number = 0.0;\n    var predphase : number = 0.0;\n    var yesterphase : number = 0.0;\n    var yesterphasediff : number = 0.0;\n    var yestermag : number = 0.0;\n    \n    var rectify : Int = 1;\n    \n    //shunt the \"old\" ODF values down one place\n    //memcpy(val + 1, val, (ods->medspan - 1) * sizeof(float)); //source\n    for (var i : Int = (medspan - 1); i > 0; i--) {\n        //unit tested in Max and works as expected shunting all values down +1 index after odfvals w/out stomping on 'sortbuf' beyond odfvals + medspan\n        onsetdetector_data_array[odfvals + i] = onsetdetector_data_array[odfvals + i - 1];\n        //post(\"---i = \");\n        //post(i);\n    }\n    \n    // Now calculate a new value and store in ods->odfvals[0]\n    switch (odftype) {\n        case 0: //power\n            //*val = (curr->nyq * curr->nyq) + (curr->dc * curr->dc); //source\n            onsetdetector_data_array[odfvals] = (onsetdetector_data_array[1] * onsetdetector_data_array[1]) + (onsetdetector_data_array[0] * onsetdetector_data_array[0]);\n            \n            for (i = 0; i < numbins; i++) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                //*val += curr->bin[i].mag * curr->bin[i].mag; //source\n                onsetdetector_data_array[odfvals] += onsetdetector_data_array[index_bin_mag] * onsetdetector_data_array[index_bin_mag];\n            }\n            break;\n            \n        case 1: //magsum\n            //*val = ods_abs(curr->nyq) + ods_abs(curr->dc); //source\n            onsetdetector_data_array[odfvals] = onsetdetector_data_array[1] + onsetdetector_data_array[0];\n\n            for (i = 0; i < numbins; i++) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                \n                //*val += ods_abs(curr->bin[i].mag); //source\n                onsetdetector_data_array[odfvals] += abs(onsetdetector_data_array[index_bin_mag]);\n            }\n            break;\n            \n        case 2: //complex\n            rectify = 0;\n            // ...and then drop through to:\n            \n        case 3: //rcomplex\n            // Note: \"other\" buf is stored in this format: mag[0],phase[0],d_phase[0],mag[1],phase[1],d_phase[1], ...\n\n            // Iterate through, calculating the deviation from expected value.\n            totdev = 0.0;\n            tbpointer = 0;\n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                \n                //curmag = ods_abs(curr->bin[i].mag); //source\n                curmag = abs(onsetdetector_data_array[index_bin_mag]);\n                \n                // Predict mag as yestermag\n                //predmag = ods->other[tbpointer++]; //source\n                predmag = onsetdetector_data_array[other + (tbpointer++)];\n                //yesterphase = ods->other[tbpointer++]; //source\n                yesterphase = onsetdetector_data_array[other + (tbpointer++)];\n                //yesterphasediff = ods->other[tbpointer++]; //source\n                yesterphasediff = onsetdetector_data_array[other + (tbpointer++)];\n                \n                // Thresholding as Brossier did - discard (ignore) bin's deviation if bin's power is minimal\n                if (curmag > odfparam) {\n                    // If rectifying, ignore decreasing bins\n                    if ((!rectify) || !(curmag < predmag)) {\n                        var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                        //i = 0 | onsetdetector_data_array[3] (bin[0] phase)\n                        //i = 1 | onsetdetector_data_array[5] (bin[1] phase)\n                        //i = 2 | onsetdetector_data_array[7] (bin[2] phase)\n                        //i = 3 | onsetdetector_data_array[9] (bin[3] phase)\n                        \n                        \n                        // Predict phase as yesterval + yesterfirstdiff\n                        predphase = yesterphase + yesterphasediff;\n\n                        // Here temporarily using the \"deviation\" var to store the phase difference\n                        //  so that the rewrap macro can use it more efficiently\n                        //deviation = predphase - curr->bin[i].phase; //source\n                        deviation = predphase - onsetdetector_data_array[index_bin_phase];\n\n                        // Deviation is Euclidean distance between predicted and actual.\n                        // In polar coords: sqrt(r1^2 +  r2^2 - r1r2 cos (theta1 - theta2))\n                        deviation = safesqrt(predmag * predmag + curmag * curmag\n                                          - predmag * curmag * cos(onsetsds_phase_rewrap(deviation)));\n\n                        totdev += deviation;\n                    }\n                }\n            }\n            \n            // totdev will be the output, but first we need to fill tempbuf with today's values, ready for tomorrow.\n            tbpointer = 0;\n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                \n                //ods->other[tbpointer++] = ods_abs(curr->bin[i].mag); // Storing mag (source)\n                onsetdetector_data_array[other + (tbpointer++)] = abs(onsetdetector_data_array[index_bin_mag]); // Storing mag\n                \n                //diff = curr->bin[i].phase - ods->other[tbpointer]; // Retrieving yesterphase from buf (source)\n                diff = onsetdetector_data_array[index_bin_phase] - onsetdetector_data_array[other + tbpointer]; // Retrieving yesterphase from buf\n                \n                //ods->other[tbpointer++] = curr->bin[i].phase; // Storing phase (source)\n                onsetdetector_data_array[other + (tbpointer++)] = onsetdetector_data_array[index_bin_phase]; // Storing phase\n                \n                // Wrap onto +-PI range\n                diff = onsetsds_phase_rewrap(diff);\n\n                //ods->other[tbpointer++] = diff; // Storing first diff to buf (source)\n                onsetdetector_data_array[other + (tbpointer++)] = diff; // Storing first diff to buf\n            }\n            \n            //*val = (float)totdev; //source\n            onsetdetector_data_array[odfvals] = totdev;\n            break;\n            \n        case 4: //phase\n            rectify = 0; //means 'use weighting' here\n            // then drop to:\n            \n        case 5: //wphase\n            // Note: \"other\" buf is stored in this format: phase[0],d_phase[0],phase[1],d_phase[1], ...\n\n            // Iterate through, calculating the deviation from expected value.\n            totdev = 0.0;\n            tbpointer = 0;\n            \n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                \n                // Thresholding as Brossier did - discard (ignore) bin's phase deviation if bin's power is low\n                //if (ods_abs(curr->bin[i].mag) > ods->odfparam) {//source\n                if (abs(onsetdetector_data_array[index_bin_mag]) > odfparam) {\n                    // Deviation is the *second difference* of the phase, which is calc'ed as curval - yesterval -\n                    // yesterfirstdiff\n                    var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                    //deviation = curr->bin[i].phase - ods->other[tbpointer] - ods->other[tbpointer + 1]; //source\n                    deviation = onsetdetector_data_array[index_bin_phase] - onsetdetector_data_array[other + tbpointer] - onsetdetector_data_array[other + tbpointer + 1];\n                    tbpointer += 2;\n                    // Wrap onto +-PI range\n                    deviation = onsetsds_phase_rewrap(deviation);\n\n                    if (rectify) { // \"rectify\" meaning \"useweighting\"...\n                        //totdev += fabs(deviation * ods_abs(curr->bin[i].mag)); //source\n                        totdev += fabs(deviation * abs(onsetdetector_data_array[index_bin_mag]));\n                    } else {\n                        totdev += fabs(deviation);\n                    }\n                }\n            }\n            \n            // totdev will be the output, but first we need to fill tempbuf with today's values, ready for tomorrow.\n            tbpointer = 0;\n            for (i = 0; i < numbins; ++i) {\n                var index_bin_phase : Int = (2 * i) + 3; //bin phase values are odd indeces starting at 3 (dc, nyq, and mag[0] are 0, 1, and 2) in 'onsetdetector_data_array')\n                //diff = curr->bin[i].phase - ods->other[tbpointer]; // Retrieving yesterphase from buf (source)\n                diff = onsetdetector_data_array[index_bin_phase] - onsetdetector_data_array[other + tbpointer]; // Retrieving yesterphase from buf\n                //ods->other[tbpointer++] = curr->bin[i].phase; // Storing phase (source)\n                onsetdetector_data_array[other + tbpointer++] = onsetdetector_data_array[index_bin_phase]; // Storing phase\n                // Wrap onto +-PI range\n                diff = onsetsds_phase_rewrap(diff);\n\n                //ods->other[tbpointer++] = diff; // Storing first diff to buf (source)\n                onsetdetector_data_array[other + tbpointer++] = diff; // Storing first diff to buf\n            }\n            //*val = (float)totdev; //<---- source (double cast to float)\n            onsetdetector_data_array[odfvals] = totdev; //pretty sure nothing needed to translate (float) casting here b/c totdev already declared as (double) 'number'\n            break;\n            \n        case 6: //mkl\n            // Iterate through, calculating the Modified Kullback-Liebler distance\n            totdev = 0.0;\n            tbpointer = 0;\n            \n            for (i = 0; i < numbins; ++i) {\n                var index_bin_mag : Int = (2 * i) + 2; //bin mag values are even indeces starting at 2 (dc and nyq are 0 and 1) in 'onsetdetector_data_array'\n                //curmag = ods_abs(curr->bin[i].mag); //source\n                curmag = abs(onsetdetector_data_array[index_bin_mag]);\n                \n                //yestermag = ods->other[tbpointer]; //source\n                yestermag = onsetdetector_data_array[other + tbpointer];\n\n                // Here's the main implementation of Brossier's MKL eq'n (eqn 2.9 from his thesis):\n                //deviation = ods_abs(curmag) / (ods_abs(yestermag) + ods->odfparam); //source\n                deviation = abs(curmag) / (abs(yestermag) + odfparam);\n                \n                totdev += log(1.0 + deviation);\n\n                // Store the mag as yestermag\n                //ods->other[tbpointer++] = curmag; //source\n                onsetdetector_data_array[other + tbpointer++] = curmag;\n            }\n            //*val = (float)totdev; //source (double cast to float)\n            onsetdetector_data_array[odfvals] = totdev; //pretty sure nothing needed to translate (float) casting here b/c totdev already declared as (double) 'number'\n            break;\n    }\n    \n    //ods->odfvals[0] *= ods->normfactor; //source\n    onsetdetector_data_array[odfvals] *= normfactor;\n}\n\n//sorts 'sortbuf' + 'medspan' values in onset_detector_data_array from lowest to highest values (unit tested)\n// Algo is simply based on http://en.wikibooks.org/wiki/Algorithm_implementation/Sorting/Selection_sort\n//void SelectionSort(float* array, int length) {\nfunction sort_selection(length) {\n    var maximum : Int;\n    var i : Int;\n    var temp : number = 0.0;\n    while (length > 0) {\n        //WARNING!!! there are no guard rails here to avoid writing out of bounds of onsetdetector_data_array, so if unexpected crashes occur check this function and add safety checks to avoid this <----\n        maximum = 0;\n        for (i = 1; i < length; i++) {\n            //if (array[i] > array[max]) //source\n                //max = i; //source\n            if (onsetdetector_data_array[sortbuf + i] > onsetdetector_data_array[sortbuf + maximum])\n            {maximum = i;}\n        }\n        //temp = array[length - 1]; //source\n        temp = onsetdetector_data_array[sortbuf + length - 1];\n        \n        //array[length - 1] = array[max]; //source\n        onsetdetector_data_array[sortbuf + length - 1] = onsetdetector_data_array[sortbuf + maximum];\n        \n        //array[max] = temp; //source\n        onsetdetector_data_array[sortbuf + maximum] = temp;\n        length--;\n    }\n}\n\n/**\n * Detects salient peaks in Onset Detection Function by removing the median,\n * then thresholding. Afterwards, the member ods.detected will indicate whether\n * or not an onset was detected.\n *\n * Not typically called directly by users since onsetsds_process() calls this.\n */\nfunction onsetsds_detect() {\n    \n    // Update last value of odfvalpost\n    odfvalpostprev = odfvalpost;\n    \n    // MEDIAN REMOVAL //\n    \n    // Copy odfvals to sortbuf\n    //memcpy(sortbuf, ods->odfvals, medspan * sizeof(float)); //source\n    for (var i : Int = 0; i < medspan; i++) {\n        var write_index: Int = sortbuf + i;\n        if (write_index >= onsetdetector_data_array_size) {\n            write_index = onsetdetector_data_array_size - 1;\n            post(\"WARNING!!! sortbuf + i write index >= onsetdetector_data_array_size\");\n            post(\"sortbuf + i write index now = onsetdetector_data_array_size - 1 to avoid crash, but onset detection will probably fail...\");\n        }\n        //unit tested in Max\n        onsetdetector_data_array[sortbuf + i] = onsetdetector_data_array[odfvals + i];\n    }\n    \n    // Sort sortbuf\n    //SelectionSort(sortbuf, medspan); //source\n    sort_selection(medspan);\n    \n    // Subtract the middlest value === the median\n    if (med_odd) {\n        //ods->odfvalpost = ods->odfvals[0] - sortbuf[(medspan - 1) >> 1]; //source\n        var sortbuf_i : Int = (medspan - 1) >> 1;\n        odfvalpost = onsetdetector_data_array[odfvals] - onsetdetector_data_array[sortbuf + sortbuf_i];\n    } else {\n        var sortbuf_i : Int = medspan >> 1;\n        //ods->odfvalpost = ods->odfvals[0] - ((sortbuf[medspan >> 1] + sortbuf[(medspan >> 1) - 1]) * 0.5f); //source\n        odfvalpost = onsetdetector_data_array[odfvals] - ((onsetdetector_data_array[sortbuf + sortbuf_i] + onsetdetector_data_array[sortbuf + sortbuf_i - 1]) * 0.5);\n    }\n    \n    // Detection not allowed if we're too close to a previous detection.\n    if (gapleft != 0) {\n        gapleft--;\n        detected = 0;\n    } else {\n        // Now do the detection.\n        detected = (odfvalpost > thresh) && (odfvalpostprev <= thresh);\n        if (detected) {\n            gapleft = mingap;\n        }\n    }\n}\n\n//Load the current frame of FFT data into onsetdetector_data_array\nfunction onsetsds_loadframe(this_fftsize) {\n    //store all fftbuf data in onsetdetector_data_array and convert to polar...\n    for (var i : Int = 0; i < this_fftsize/2; i++) {\n        if (i < 1) {\n            //post(\"===========\");\n            //no polar conversion needed for these...\n            var dc = peek(fftbuf, 0);\n            var nyq = peek(fftbuf, 1);\n            onsetdetector_data_array[0] = dc[0];\n            onsetdetector_data_array[1] = nyq[0];\n        }\n        else if (i >= 1 && (i < this_fftsize/2)) {\n            var index_x : Int = 2 * i;\n            var index_y : Int = index_x + 1;\n            var real = peek(fftbuf, index_x);\n            var imaginary = peek(fftbuf, index_y);\n            \n            var polar = cartopol(real[0], imaginary[0]);\n            onsetdetector_data_array[index_x] = polar[0]; //mag\n            onsetdetector_data_array[index_y] = polar[1]; //phase\n        }\n    }\n}\n\n/**\n * Process a single FFT data frame in the audio signal. Note that processing\n * assumes that each call to onsetsds_process() is on a subsequent frame in\n * the same audio stream - to handle multiple streams you must use separate\n * OnsetsDS structs and memory!\n *\n * This function's main purpose is to call some of the library's other functions,\n * in the expected sequence.\n */\n//bool onsetsds_process(OnsetsDS* ods, float* fftbuf) {//source\nfunction onsetsds_process() {\n    onsetsds_loadframe(fftsize);\n\n    onsetsds_whiten(); //<---CAUSES warning: 3755:1:non-void function does not return a value in all control paths\n                        //error: 3883:9:non-void function 'codebox_02_onsetsds_whiten' should return a value\n    onsetsds_odf();\n    onsetsds_detect();\n\n    //return ods->detected; //source\n    //return detected; //<---I think this should be fine in RNBO, but try commenting this out if run into issues, since 'detected' is a @state variable and accessible always\n}\n\n\nfunction Onsets_next() {\n    var outval : Int = 0; //maybe not needed if use final output line instead\n    //source --- vvvv --- vvvv ---------------\n    //Onsets_GET_BUF //source <---handled in other 'fftbuf_write' codebox\n    //SCPolarBuf* p = ToPolarApx(buf); buf comes from Onsets_GET_BUF macro <---TRANSLATED INTO onsetsds_loadframe()\n    //OnsetsDS* ods = unit->m_ods;\n    //int odftype = (int)ZIN0(2);\n    //float relaxtime = ZIN0(3);\n    //int medspan = (int)ZIN0(6);\n    //source --- ^^^^ --- ^^^^ ---------------\n    \n    if (needs_init) {\n        \n        // Init happens here because we need to be sure about FFT size (buf->samples)\n        //unit->m_odsdata = (float*)RTAlloc(unit->mWorld, onsetsds_memneeded(odftype, buf->samples, medspan)); //calculate data size and allocate memory for odsdata <---TRANSLATED THIS INTO onsetsds_init()\n        //ClearUnitIfMemFailed(unit->m_odsdata);\n\n        //onsetsds_init(ods, unit->m_odsdata, ODS_FFT_SC3_POLAR, odftype, buf->samples, medspan, FULLRATE); //init ods struct w/ correct data size, pointer addresses, and parameters\n        onsetsds_init(odftype, fftsize, medspan);\n        \n        //onsetsds_setrelax(ods, relaxtime, buf->samples >> 1);\n        onsetsds_setrelax(relaxtime, fftsize >> 1);\n\n        //unit->m_needsinit = false;\n        needs_init = 0;\n    }\n\n    //source --- vvvv --- vvvv ---------------\n    // Here is the best place to set parameters - after init is ensured\n    // These are \"painless\" to set:\n    //ods->thresh = ZIN0(1);\n    //ods->floor = ZIN0(4);\n    //ods->mingap = (int)ZIN0(5);\n    //ods->whtype = (int)ZIN0(7);\n    //source --- ^^^^ --- ^^^^ ---------------\n    \n    // Now to process\n    //unit->outval = onsetsds_process(ods, (float*)p);\n    //outval = onsetsds_process();\n    onsetsds_process();\n    \n    if (detected > 0) {post(\"ONSET DETECTED\");}\n    //ZOUT0(0) = unit->outval;\n    out1 = detected;\n    //out1 = detected;\n}\n\n//===============================\n//===============================\n//=== TOP of odf()===\n\nif (!(last_thresh == thresh)) {\n    post(\"in-odf --> NEW thresh = \", thresh);\n    post(\"in-odf --> LAST thresh = \", last_thresh);\n    last_thresh = thresh;\n}\n\nif (!(last_relaxtime == relaxtime)) {\n    post(\"in-odf --> NEW relaxtime = \", relaxtime);\n    post(\"in-odf --> LAST relaxtime = \", last_relaxtime);\n    last_relaxtime = relaxtime;\n}\n\nif (!(last_floor == floor)) {\n    post(\"in-odf --> NEW floor = \", floor);\n    post(\"in-odf --> LAST floor = \", last_floor);\n    last_floor = floor;\n}\n\nif (!(last_mingap == mingap)) {\n    post(\"in-odf --> NEW mingap = \", mingap);\n    post(\"in-odf --> LAST mingap = \", last_mingap);\n    last_mingap = mingap;\n}\n\nif (!(last_medspan == medspan)) {\n    post(\"in-odf --> NEW medspan = \", medspan);\n    post(\"in-odf --> LAST medspan = \", last_medspan);\n    last_medspan = medspan;\n}\n\nif (!(last_odftype == odftype)) {\n    post(\"in-odf --> NEW odftype = \", odftype);\n    post(\"in-odf --> LAST odftype = \", last_odftype);\n    last_odftype = odftype;\n}\n\nif (!(last_fftsize == fftsize)) {\n    post(\"in-odf --> NEW fftsize = \", fftsize);\n    post(\"in-odf --> LAST fftsize = \", last_fftsize);\n    last_fftsize = fftsize;\n}\n\nif (!(last_needs_init == needs_init)) {\n    post(\"in-odf --> NEW needs_init = \", needs_init);\n    post(\"in-odf --> LAST needs_init = \", last_needs_init);\n    last_needs_init = needs_init;\n}\n\nOnsets_next();\n\n",
						"safemath" : 1,
						"hot" : 0
					}
,
					"rnbo_serial" : 6,
					"rnbo_uniqueid" : "codebox_obj-34",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset all state and params to initial values",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"out1" : 							{
								"attrOrProp" : 1,
								"digest" : "out1",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 0,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"thresh" : 							{
								"attrOrProp" : 1,
								"digest" : "thresh",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0.5"
							}
,
							"relaxtime" : 							{
								"attrOrProp" : 1,
								"digest" : "relaxtime",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1"
							}
,
							"floor" : 							{
								"attrOrProp" : 1,
								"digest" : "floor",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0.1"
							}
,
							"mingap" : 							{
								"attrOrProp" : 1,
								"digest" : "mingap",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "10"
							}
,
							"medspan" : 							{
								"attrOrProp" : 1,
								"digest" : "medspan",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "11"
							}
,
							"odftype" : 							{
								"attrOrProp" : 1,
								"digest" : "odftype",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1"
							}
,
							"whtype" : 							{
								"attrOrProp" : 1,
								"digest" : "whtype",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1"
							}
,
							"fftsize" : 							{
								"attrOrProp" : 1,
								"digest" : "fftsize",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "64"
							}
,
							"needs_init" : 							{
								"attrOrProp" : 1,
								"digest" : "needs_init",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1"
							}
,
							"in1" : 							{
								"attrOrProp" : 1,
								"digest" : "in1",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 0,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "bang"
							}
,
							"expr" : 							{
								"attrOrProp" : 2,
								"digest" : "expr",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"doNotShowInMaxInspector" : 1
							}
,
							"hot" : 							{
								"attrOrProp" : 2,
								"digest" : "Trigger computation on all inlets.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"safemath" : 							{
								"attrOrProp" : 2,
								"digest" : "Use safe math expressions (e.g.: division by 0 will not crash).",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true"
							}

						}
,
						"inputs" : [ 							{
								"name" : "in1",
								"type" : "bang",
								"digest" : "in1",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : "number",
								"digest" : "out1",
								"docked" : 0
							}
 ],
						"helpname" : "codebox",
						"aliasOf" : "expr",
						"classname" : "codebox",
						"operator" : 0,
						"versionId" : -1920135016,
						"changesPatcherIO" : 0
					}

				}

			}
, 			{
				"box" : 				{
					"id" : "obj-23",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 2,
					"outlettype" : [ "", "" ],
					"patching_rect" : [ 1977.0, 122.0, 409.0, 23.0 ],
					"rnbo_classname" : "param",
					"rnbo_extra_attributes" : 					{
						"minimum" : 0.0,
						"tonormalized" : "",
						"preset" : 1,
						"exponent" : 1.0,
						"value" : 0.0,
						"meta" : "",
						"displayorder" : "-",
						"unit" : "",
						"ctlin" : 0.0,
						"sendinit" : 1,
						"order" : "0",
						"displayname" : "",
						"maximum" : 1.0,
						"steps" : 0.0,
						"fromnormalized" : ""
					}
,
					"rnbo_serial" : 16,
					"rnbo_uniqueid" : "odftype",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"value" : 							{
								"attrOrProp" : 2,
								"digest" : "Set initial value",
								"defaultarg" : 2,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Initial Value",
								"displayorder" : 3
							}
,
							"normalizedvalue" : 							{
								"attrOrProp" : 1,
								"digest" : "Set value normalized. ",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"inlet" : 1,
								"type" : "number"
							}
,
							"reset" : 							{
								"attrOrProp" : 1,
								"digest" : "Reset param to initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 1,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bang"
							}
,
							"normalized" : 							{
								"attrOrProp" : 1,
								"digest" : "Normalized parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "number"
							}
,
							"name" : 							{
								"attrOrProp" : 2,
								"digest" : "Name of the parameter",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "Parameter Name",
								"mandatory" : 1
							}
,
							"enum" : 							{
								"attrOrProp" : 2,
								"digest" : "Use an enumerated output",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "list",
								"label" : "Enum Values",
								"displayorder" : 6
							}
,
							"minimum" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 0,
								"aliases" : [ "min" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"min" : 							{
								"attrOrProp" : 2,
								"digest" : "Minimum value",
								"isalias" : 1,
								"aliasOf" : "minimum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Minimum",
								"displayorder" : 1
							}
,
							"maximum" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 0,
								"aliases" : [ "max" ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"max" : 							{
								"attrOrProp" : 2,
								"digest" : "Maximum value",
								"isalias" : 1,
								"aliasOf" : "maximum",
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Maximum",
								"displayorder" : 2
							}
,
							"exponent" : 							{
								"attrOrProp" : 2,
								"digest" : "Scale values exponentially",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "1",
								"label" : "Exponent",
								"displayorder" : 7
							}
,
							"steps" : 							{
								"attrOrProp" : 2,
								"digest" : "Divide the output into a number of discrete steps",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"defaultValue" : "0",
								"label" : "Steps",
								"displayorder" : 8
							}
,
							"displayName" : 							{
								"attrOrProp" : 2,
								"digest" : "DEPRECATED: Use the lower case 'displayname' instead",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "symbol",
								"label" : "Display Name"
							}
,
							"displayname" : 							{
								"attrOrProp" : 2,
								"digest" : "A more readable name for the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Display Name",
								"displayorder" : 14
							}
,
							"unit" : 							{
								"attrOrProp" : 2,
								"digest" : "A symbol to describe the unit of the parameter in an external RNBO target",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Unit",
								"displayorder" : 15
							}
,
							"tonormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a real parameter value to its normalized form.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "To Normalized Expression",
								"displayorder" : 10
							}
,
							"fromnormalized" : 							{
								"attrOrProp" : 2,
								"digest" : "Converts a normalized parameter into its actual parameter value.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"label" : "From Normalized Expression",
								"displayorder" : 9
							}
,
							"order" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which initial parameter values will be sent out on patcher load. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "0",
								"label" : "Restore Order",
								"displayorder" : 12
							}
,
							"displayorder" : 							{
								"attrOrProp" : 2,
								"digest" : "Order in which parameters will show up in a list of all parameters. The order can be numeric or symbolic ('first' and 'last')",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "-",
								"label" : "Display Order",
								"displayorder" : 13
							}
,
							"sendinit" : 							{
								"attrOrProp" : 2,
								"digest" : "Send initial value",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Send Init",
								"displayorder" : 4
							}
,
							"ctlin" : 							{
								"attrOrProp" : 2,
								"digest" : "MIDI controller number to control this parameter.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"label" : "MIDI Controller Number.",
								"displayorder" : 16
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 17
							}
,
							"nopreset" : 							{
								"attrOrProp" : 2,
								"digest" : "Do not add this value to the preset [DEPRECATED - USE @preset 0 instead].",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 1,
								"type" : "bool",
								"defaultValue" : "false"
							}
,
							"preset" : 							{
								"attrOrProp" : 2,
								"digest" : "Add this value to the preset.",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "bool",
								"defaultValue" : "true",
								"label" : "Include In Preset",
								"displayorder" : 11
							}

						}
,
						"inputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalizedvalue",
								"type" : "number",
								"digest" : "Set value normalized. ",
								"docked" : 0
							}
 ],
						"outputs" : [ 							{
								"name" : "value",
								"type" : "number",
								"digest" : "Parameter value",
								"hot" : 1,
								"docked" : 0
							}
, 							{
								"name" : "normalized",
								"type" : "number",
								"digest" : "Normalized parameter value.",
								"docked" : 0
							}
 ],
						"helpname" : "param",
						"aliasOf" : "param",
						"classname" : "param",
						"operator" : 0,
						"versionId" : -1940971094,
						"changesPatcherIO" : 0
					}
,
					"text" : "param odftype @enum power magsum complex rcomplex phase wphase mkl",
					"varname" : "odftype"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-11",
					"maxclass" : "newobj",
					"numinlets" : 2,
					"numoutlets" : 3,
					"outlettype" : [ "signal", "signal", "signal" ],
					"patching_rect" : [ 52.0, 98.0, 182.0, 23.0 ],
					"rnbo_classname" : "fftstream~",
					"rnbo_extra_attributes" : 					{
						"win_bufname" : "RNBODefaultFftWindow",
						"phase" : 0
					}
,
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "fftstream~_obj-11",
					"text" : "fftstream~ #1 #1 @window hann"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-4",
					"maxclass" : "newobj",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 666.0, 1006.0, 57.0, 23.0 ],
					"rnbo_classname" : "out",
					"rnbo_extra_attributes" : 					{
						"comment" : "",
						"meta" : ""
					}
,
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "out_obj-4",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "outlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [ 							{
								"name" : "in1",
								"type" : [ "bang", "number", "list" ],
								"digest" : "value sent to outlet with index 1",
								"displayName" : "",
								"hot" : 1,
								"docked" : 0
							}
 ],
						"outputs" : [  ],
						"helpname" : "out",
						"aliasOf" : "out",
						"classname" : "out",
						"operator" : 0,
						"versionId" : -735743983,
						"changesPatcherIO" : 1
					}
,
					"text" : "out 1"
				}

			}
, 			{
				"box" : 				{
					"id" : "obj-3",
					"maxclass" : "newobj",
					"numinlets" : 0,
					"numoutlets" : 1,
					"outlettype" : [ "signal" ],
					"patching_rect" : [ 52.0, 28.0, 35.0, 23.0 ],
					"rnbo_classname" : "in~",
					"rnbo_extra_attributes" : 					{
						"comment" : "",
						"meta" : ""
					}
,
					"rnbo_serial" : 2,
					"rnbo_uniqueid" : "in~_obj-3",
					"rnboinfo" : 					{
						"needsInstanceInfo" : 1,
						"argnames" : 						{
							"out1" : 							{
								"attrOrProp" : 1,
								"digest" : "signal from inlet with index 1",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 0,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"outlet" : 1,
								"type" : "signal"
							}
,
							"index" : 							{
								"attrOrProp" : 2,
								"digest" : "inlet number",
								"defaultarg" : 1,
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "number",
								"mandatory" : 1
							}
,
							"comment" : 							{
								"attrOrProp" : 2,
								"digest" : "mouse over comment",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol"
							}
,
							"meta" : 							{
								"attrOrProp" : 2,
								"digest" : "A JSON formatted string containing metadata for use by the exported code",
								"isalias" : 0,
								"aliases" : [  ],
								"settable" : 1,
								"attachable" : 0,
								"isparam" : 0,
								"deprecated" : 0,
								"type" : "symbol",
								"defaultValue" : "",
								"label" : "Metadata",
								"displayorder" : 3
							}

						}
,
						"inputs" : [  ],
						"outputs" : [ 							{
								"name" : "out1",
								"type" : "signal",
								"digest" : "signal from inlet with index 1",
								"displayName" : "",
								"docked" : 0
							}
 ],
						"helpname" : "in~",
						"aliasOf" : "in~",
						"classname" : "in~",
						"operator" : 0,
						"versionId" : -176007711,
						"changesPatcherIO" : 1
					}
,
					"text" : "in~ 1"
				}

			}
 ],
		"lines" : [ 			{
				"patchline" : 				{
					"destination" : [ "obj-103", 0 ],
					"order" : 0,
					"source" : [ "obj-1", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-92", 0 ],
					"order" : 1,
					"source" : [ "obj-1", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-32", 0 ],
					"source" : [ "obj-107", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-107", 0 ],
					"source" : [ "obj-108", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-32", 2 ],
					"midpoints" : [ 224.5, 158.0, 533.5, 158.0 ],
					"source" : [ "obj-11", 2 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-32", 1 ],
					"midpoints" : [ 143.0, 168.0, 297.5, 168.0 ],
					"source" : [ "obj-11", 1 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-32", 0 ],
					"midpoints" : [ 61.5, 153.0, 61.5, 153.0 ],
					"source" : [ "obj-11", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-19", 0 ],
					"source" : [ "obj-22", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-26", 0 ],
					"source" : [ "obj-22", 1 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-33", 0 ],
					"source" : [ "obj-22", 2 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-89", 0 ],
					"source" : [ "obj-23", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-11", 0 ],
					"source" : [ "obj-3", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-22", 0 ],
					"source" : [ "obj-30", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-4", 0 ],
					"source" : [ "obj-34", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-49", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-49", 0 ],
					"source" : [ "obj-50", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-50", 0 ],
					"source" : [ "obj-68", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-74", 0 ],
					"source" : [ "obj-69", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-76", 0 ],
					"source" : [ "obj-70", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-78", 0 ],
					"source" : [ "obj-71", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-80", 0 ],
					"source" : [ "obj-72", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-82", 0 ],
					"source" : [ "obj-73", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-75", 0 ],
					"source" : [ "obj-74", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-75", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-77", 0 ],
					"source" : [ "obj-76", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-77", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-79", 0 ],
					"source" : [ "obj-78", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-79", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-81", 0 ],
					"source" : [ "obj-80", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-81", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-83", 0 ],
					"source" : [ "obj-82", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-83", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-85", 0 ],
					"source" : [ "obj-84", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-86", 0 ],
					"source" : [ "obj-85", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-86", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-23", 0 ],
					"source" : [ "obj-87", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-89", 0 ]
				}

			}
, 			{
				"patchline" : 				{
					"destination" : [ "obj-34", 0 ],
					"source" : [ "obj-92", 0 ]
				}

			}
 ],
		"default_bgcolor" : [ 0.031372549019608, 0.125490196078431, 0.211764705882353, 1.0 ],
		"color" : [ 0.929412, 0.929412, 0.352941, 1.0 ],
		"elementcolor" : [ 0.357540726661682, 0.515565991401672, 0.861786782741547, 1.0 ],
		"accentcolor" : [ 0.343034118413925, 0.506230533123016, 0.86220508813858, 1.0 ],
		"stripecolor" : [ 0.258338063955307, 0.352425158023834, 0.511919498443604, 1.0 ],
		"bgfillcolor_type" : "color",
		"bgfillcolor_color" : [ 0.031372549019608, 0.125490196078431, 0.211764705882353, 1.0 ],
		"bgfillcolor_color1" : [ 0.031372549019608, 0.125490196078431, 0.211764705882353, 1.0 ],
		"bgfillcolor_color2" : [ 0.263682, 0.004541, 0.038797, 1.0 ],
		"bgfillcolor_angle" : 270.0,
		"bgfillcolor_proportion" : 0.39,
		"bgfillcolor_autogradient" : 0.0
	}

}
